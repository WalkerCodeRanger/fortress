(*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component FortressLibrary
(* import * from NativeArray *)
export Executable

(** The following function is actually recognized as a special piece
    of built-in magic by the Fortress interpreter.  The javaClass
    argument names a Java Class which is a subclass of
    com.sun.fortress.interpreter.glue.NativeApp, which provides code
    for the closure which is used in place of the call to
    builtinPrimitive.  Meanwhile all the necessary type information,
    argument names, etc. must be declared here in Fortress-land.  For
    examples see the end of this file.

    In practice if you're extending the interpreter you will probably
    want to extend com.sun.fortress.interpreter.glue.NativeFn0,1,2,3,4
    or one of their subclasses defined in
    com.sun.fortress.interpreter.glue.primitive.  These types are
    generally easier to work with, and the boilerplate packing and
    unpacking of values is done for you.
*)

builtinPrimitive[\T\](javaClass:String):T =
  fail ("Implementation should not invoke builtinPrimitive " javaClass)

(** Builtin types from evaluator.Primitives.java:

Here "object" really implies non-extensibility.

trait  Number        extends { Any }         excludes { String, Boolean }
trait  Integral      extends { Number }      excludes { String, Boolean, RR64, FloatLiteral }
object ZZ32          extends { Integral }    excludes { String, Boolean, RR64, FloatLiteral }
object ZZ64          extends { Integral }    excludes { String, Boolean, RR64, FloatLiteral }
object RR64          extends { Number }      excludes { String, Boolean }
object String        extends { Any }         excludes { IntLiteral, FloatLiteral, Boolean }
object IntLiteral    extends { ZZ32, ZZ64, RR64 }
object FloatLiteral  extends { RR64 }
object Boolean       extends { Any }

trait  Any           extends {}
  Note that everything is considered to extend the type Any.

Note also that there isn't (yet) a trait Object!  Eventually
user-written trait and object declarations will extend Object by
default; right now they instead extend Any by default.

Note also that most of these types should not form a hierarchy, but
instead a flat type space with coercions between constituents.  Due to
the absence of coercion we have the rather unfortunate situation you
see here.

*)

(** Equality *)

(* Ideally equality will become a more ubiquitous funcitonal method.
   Right now bugs mean equality is only a funcitonal method for the
   Maybe type. *)
opr =(a:Any, b:Any):Boolean = false
opr =/=(a:Any, b:Any):Boolean = NOT (a=b)

(** Assertion *)
assert(flag:Boolean): () =
    if NOT flag then
        fail("Assertion failed!")
    end

assert(flag: Boolean, failMsg: String): () =
    if NOT flag then
        fail(failMsg)
    end

assert(x:Any, y:Any, failMsg: String): () =
    if x =/= y then
        fail(x " =/= " y "; " failMsg)
    end

(** Generator
 *
 * We say an object which extends Generator[\T\] "generates objects of
 * type T."
 *
 * Generators are used to express iteration in Fortress.  Every
 * generated expression in Fortress (eg for loop, comprehension) is
 * desugared into calls to methods of Generator, chiefly the generate
 * method.
 *
 * Every generator has a notion of a "natural order" (which by default is
 * unspecified), which describes the ordering of reduction operations,
 * and also describes the order in which elements are produced by the
 * sequential version of the same generator (given by the seq()
 * method).  The default implementation of seq() guarantees that these
 * orders will match.
 *
 * Note in particular that the natural order of a Generator must be
 * consistent; that is, if a SEQV b then a and b must yield SEQV
 * elements in the same natural order.  However, note that unless a type
 * specifically documents otherwise, no particular element ordering is
 * guaranteed, nor is it necessary to guarantee that a=b have the same
 * natural order when equality is defined.
 *
 * Note that more complex derived generators are specified further
 * down in the definition of Generator.  These have the same notions
 * of natural order and by default are defined in terms of the
 * generate() method.
 *
 * Minimal complete definition of a Generator is the size() and
 * generate(...) methods.
 *)

trait Generator[\E\]
    getter isEmpty(): Boolean = size()=0
    getter size(): ZZ32

    (** generate is the core of Generator.  It generates elements of
        type E and passes them to the body function.  This generation
        can occur using any mixture of serial and parallel execution
        desired by the author of the generator; by default uses of a
        generator must assume every call to the body occurs in
        parallel.

        The results of generation are combined using the reduction
        object R, which specifies a monoidal operation (associative
        and with an identity).  Body results must be combined together
        following the natural order of the generator.  The author of
        the generator is free to use the identity element anywhere
        desired in this computation, and to group reductions in any
        way desired; if no elements are generated the identity must be
        returned. *)
    generate[\R\](r: Reduction[\R\], body: E->R): R

    (** Transforming generators into new generators *)
    (** map applies a function f to each element generated and yields
        the result.  The resulting generator must have the same
        ordering and cross product properties as the generator from
        which it is derived. *)
    map[\G\](f: E->G): Generator[\G\] = SimpleMappedGenerator[\E,G\](self,f)
    (** seq produces a sequential version of the same generator, in
        which elements are produced in the generator's natural order. *)
    seq(): SequentialGenerator[\E\] = NaiveSeqGenerator[\E\](self)

    (** Cross product of two generators.  This is specifically
        designed to be overloaded, such that pairs of independent
        generators can be combined to produce a generator which
        possibly interleaves the iteration spaces of the two
        generators.  For example, we might combine (0#16).cross(0#32)
        such that it first splits the second range in half, then the
        first range in half, then the second, and so forth.

        Consider a grid for which the rows are labeled from top to
        bottom with the elements of a in natural order, and the
        columns are labeled from left to right with the elements of g
        in natural order.  Each point in the grid corresponds to a
        pair (a,b) that must be generated by self.cross(g).  In the
        natural order of the cross product, an element must occur
        after those that lie above and to the left of it in the grid.
        By default the natural order of the cross product is
        left-to-right, top to bottom.  Programmers must not rely on
        the default order, except that cross products involving one or
        more sequential generators are always performed in the default
        order.  Note that this means that the following have the same
        natural order:
           seq(a).cross(b)
           a.cross(seq(b))
           seq(a).cross(seq(b))
        But seq(a.cross(b)) may have a different natural order. *)
    cross[\G\](g: Generator[\G\]): Generator[\(E,G)\] =
        SimplePairGenerator[\E,G\](self, g)
(*
    cross[\G\](g: Nothing[\G\]): Generator[\(E,G)\] = Nothing[\(E,G)\]()
    cross[\G\](g: Just[\G\]): Generator[\(E,G)\] =
        map[\(E,G)\](fn (e:E):(E,G) => (e, g.unJust()))
*)

    (** Derived generation operations *)
    (** mapReduce is equivalent to generate, but takes an explicit join
    and zero which can have any type.  It still assumes join is
    associative and that zero is the identity of join. *)
    mapReduce[\R\](body: E->R, join:(R,R)->R, zero:R): R =
        generate[\R\](MapReduceReduction[\R\](join,zero), body)
    (** reduce works much like generate or mapReduce, but has no body expression *)
    reduce(j:(E,E)->E, z:E):E = mapReduce[\E\](fn (e:E)=>e, j, z)
    reduce(r: Reduction[\E\]):E = generate[\E\](r, fn(e:E)=>e)
    (** loop is a version of generate which discards the void results
        of the body computation.  It is used to translated
        reduction-variable-free for loops. *)
    loop(f:E->()): () = generate[\()\](VoidReduction, f)
end

trait SequentialGenerator[\E\] extends { Generator[\E\] }
    seq() = self
end

(** Operations which use generation internally.  Should be functional
    methods of Generator, but that didn't work when last tested. *)

(** IN returns true if any element generated by its second argument is
    = to its first argument.  x NOTIN g is simply NOT (x IN g).
    Unless documented otherwise, this is O(n) for an n-element
    Generator (it simply performs naive matching).  *)
opr IN[\E\](x: E, this: Generator[\E\]): Boolean =
    this.generate[\Boolean\](OrReduction, fn (y: E) => x=y)
opr NOTIN[\E\](x: E, this: Generator[\E\]): Boolean = NOT (x IN this)

seq[\T\](g:Generator[\T\]):Generator[\T\] = g.seq()
sequential[\T\](g:Generator[\T\]):Generator[\T\] = g.seq()


(** Maybe type *)

(* This makes excludes work without where clauses, and allows opr =()
   to remain non-parametric. *)
value trait MaybeType excludes { Number }
    (* comprises Maybe[\T\] where [\T\] *)
  getter isJust() : Boolean
end

(** Maybe[\T\] represents either Nothing or a single element of type T
    (Just[\T\]), which may be retrieved by calling unJust().  An
    object of type Maybe[\T\] can be used as a generator; it is either
    empty (Nothing) or generates the single element yielded by unJust,
    so there is no issue of canonical order.

    Thus Just[\T\] can be used as a single-element generator, and
    Nothing can be used as an empty generator. *)
value trait Maybe[\T\]
    extends { MaybeType, SequentialGenerator[\T\]}
    comprises { Nothing[\T\], Just[\T\] }
  getter unJust() : T throws UnJustNothing
  maybe[\R\](nothingAction: ()->R, justAction: T->R): R
end

value object Just[\T\](x:T) extends {Maybe[\T\]}
    getter size()=1
    getter toString():String = "Just(" x ")"
    getter isJust() = true
    getter unJust() = x
    opr =(self, o:Just[\T\]) = (x=o.unJust())
    generate[\R\](_:Reduction[\R\],m:T->R): R = m(x)

    map[\G\](f: T->G): Generator[\G\] = Just[\G\](f(x))
    cross[\G\](g: Generator[\G\]): Generator[\(T,G)\] =
        g.map[\(T,G)\](fn (e:G):(T,G) => (x,e))

    mapReduce[\R\](m: T->R, _:(R,R)->R, _:R): R = m(x)
    reduce(_:(T,T)->T, _:T):T = x
    reduce(_: Reduction[\T\]):T = x
    loop(f:T->()): () = f(x)
    maybe[\R\](_: ()->R, justAction: T->R): R = justAction(x)
end

(* Obviously ought to be a non-parametric singleton when we get where
   clauses working. *)
value object Nothing[\T\]() extends { Maybe[\T\] }
    getter size()=0
    getter isJust() = false
    getter unJust() = throw UnJustNothing
    getter toString():String = "Nothing"
    opr =(self, o:Nothing[\T\]) = true
    generate[\R\](r:Reduction[\R\],_:T->R): R = r.empty()

    map[\G\](f: T->G): Generator[\G\] = Nothing[\G\]()
    cross[\G\](g: Generator[\G\]): Generator[\(T,G)\] = Nothing[\(T,G)\]()

    mapReduce[\R\](_: T->R, _:(R,R)->R, z:R): R = z
    reduce(_:(T,T)->T, z:T):T = z
    reduce(r: Reduction[\T\]):T = r.empty()
    loop(f:T->()): () = ()
    maybe[\R\](nothingAction: ()->R, _: T->R): R = nothingAction()
end

opr IN[\E\](x: E, g: Nothing[\E\]): Boolean = false
opr NOTIN[\E\](x: E, g: Nothing[\E\]): Boolean = true
opr IN[\E\](x: E, g: Just[\E\]): Boolean = x=g.unJust()
opr NOTIN[\E\](x: E, g: Just[\E\]): Boolean = x=/=g.unJust()

(** Exception hierarchy *)

trait Exception comprises { UncheckedException, CheckedException }
end

(* Exceptions which are not checked *)

trait UncheckedException extends Exception excludes CheckedException
end

(*********  Commented out until we actually make exceptions work.

object FailCalled(s:String) extends UncheckedException
  toString(): String = "FAIL: " s
end

(* also referred to as DivideByZeroException *)
object DivisionByZero extends UncheckedException
end

object UnpastingException extends UncheckedException
end

object CallerViolation extends UncheckedException
end

object CalleeViolation extends UncheckedException
end

object TestFailure extends UncheckedException
end

object ContractHierarchyViolation extends UncheckedException
end

object NoEqualityOnFunctions extends UncheckedException
end

object InvalidRange extends UncheckedException
end

object ForbiddenException(chain : Exception) extends UncheckedException
end

(* Should this be called "IndexNotFound" instead? *)
object NotFound extends UncheckedException
end

(* Drop "Exception" from these? *)
object IndexOutOfBoundsException extends UncheckedException
end

object NegativeLengthException extends UncheckedException
end

object IntegerOverflowException extends UncheckedException
end

object RationalComparisonException extends UncheckedException
end

object FloatingComparisonException extends UncheckedException
end


*****************)

(* Checked Exceptions *)

trait CheckedException extends Exception excludes UncheckedException
end

(**************** Commented out until we actually have exceptions.

object CastException extends CheckedException
end

object IOException extends CheckedException
end

object MatchFailure extends CheckedException
end

object UnJustNothing extends CheckedException
end

(* SetsNotDisjoint? *)
object DisjointUnionException extends CheckedException
end

object APIMissing extends CheckedException
end

object APINameCollision extends CheckedException
end

object ExportedAPIMissing extends CheckedException
end

object HiddenAPIMissing extends CheckedException
end

trait TryAtomicException extends {CheckedException}
  comprises {AtomicAborted, AtomicConflict}
end

object AtomicAborted extends TryAtomicException
end

object AtomicConflict extends TryAtomicException
end

(* Should take a spawned thread as an argument *)
object AtomicSpawnSynchronization extends {UncheckedException}
end

***************)

(** Casting *)

cast[\T\](x:Any):T =
  typecase x of
    T => x
    else => printTaskTrace(); throw CastException
  end

instanceOf[\T\](x:Any):Boolean =
  typecase x of
    T => true
    else => false
  end

(** Useful functions *)

ignore(_:Any):() = ()

identity[\T\](x:T):T = x

(** Transactional retry *)
retry[\T\]():T = fail("Transactional retry not yet implemented.")

(* Should we depracate tuple and use identity instead?  Decision: no. *)
tuple[\T\](x:T):T = x

(* Function composition *)
opr COMPOSE[\A,B,C\](f: B->C, g: A->B): A->C = fn (a:A): C => f(g(a))

(* Retrieve values from tuples in a well-typed way. *)
first[\T\](t:T, u:Any...): T = t

second[\A,T\](a:A, t:T, u:Any...): T = t

third[\A,B,T\](a:A, b:B, t:T, u:Any...): T = t

(** Reflection for run-time integers into compile-time nat parameters.
 *
 *  Basically you can call the function reflect(n) and it will return
 *  an instance of NatParam.  But every instance of NatParam is an
 *  object N[\n\], so we can write a function which takes N[\n\] and
 *  pass it a NatParam; within that function n becomes a static nat
 *  parameter.
 *)
trait NatParam
  (* comprises { N[\n\] } where [\ nat n \] *)
  getter toZZ() : ZZ32
  getter toString()
end

value object N[\nat n\]() extends { NatParam }
  toZZ() = n
  toString() = "" n
end

(* Inner loop of reflect, hoisted to top level because of incomplete
 * implementation of generic local functions.  This basically
 * decomposes the argument x into binary digits, and does the same
 * operations on the static parameter r as it does so.
 *
 * Really this just proves that it can be done without extending the
 * language.  Having proven that, we ought to build it in and document
 * it in the spec for clarity and sanity's sake.
 *)
  __refl'[\nat r, nat b\](x:ZZ32):NatParam =
    if x=0 then N[\r\]()
    elif (x REM (b+b)) = 0 then
      __refl'[\r, b+b\](x)
    else
      __refl'[\r+b, b+b\](x-b)
    end

(* Actually convert a ZZ32 into a NatParam. *)
reflect(z:ZZ32):NatParam = do
  if z < 0 then
    fail("reflect(" z "): " negative argument)
  else
    __refl'[\0,1\](z)
  end
end

(** Reflection of static type parameters for overloading purposes.
    Works around shortcomings in the story on parametric overloading
    (all overloadings must have the same parameters with the same
    bounds).  Allows us to overload a function based on the parametric
    type of an output. *)

object __Proxy[\T extends (* U *) Any\]()
    (* extends { __Proxy[\U\], Object } where { U extends Any } *)
  getter toString() = "__Proxy object, should not be user-visible."
end

(** Boilerplate code for Array *)

fail(s:String) = do
   println("FAIL: " s)
   printTaskTrace()
   throwError(s)
   throw FailCalled(s)
end

oops(s:ZZ32, l:ZZ32, sz:ZZ32, got:ZZ32):() = do
   fail("For subscript " s " wanted " l "#" sz " but got " got);
end

trait HasRank excludes { Number, MaybeType }
  (* comprises Array[\T,E,I\] where [\T,E,I\]{ T extends Array[\T,E,I\] } *)
  rank():ZZ32
  eq(o:HasRank):Boolean = false
end

opr =(a:HasRank, b:HasRank):Boolean = a.eq(b)

(* Declared Rank-n-ness *)
trait Rank[\ nat n \] extends HasRank
  rank():ZZ32 = n
end

(* Potemkin exclusion traits.  Really we just want to say that
 * Rank[\n\] excludes Rank[\m\] where { m =/= n }, but we can't yet. *)

trait Rank1 extends { Rank[\1\]} excludes { Rank2, Rank3, Number, String }
end

trait Rank2 extends { Rank[\2\]} excludes { Rank3, Number, String }
end

trait Rank3 extends { Rank[\3\]} excludes { Number, String }
end

(* The trait Indexed_i[\n\] indicates that something has an i^th
 * dimension of size n.  In general anything which extends Indexed_i
 * must also extend Indexed_j for j < i. *)

trait Indexed1[\ nat n \] end

trait Indexed2[\ nat n \] end

trait Indexed3[\ nat n \] end

(** The indexed trait indicates that an object of type T can be
indexed using type I to obtain elements with type E.


An object i that's an instance of Indexed defines three basic things:
  The indexing operator, which must be defined for every instance of
    the type.
  A suite of generators:  i.indices generates the index space of the
    array.  i itself generates the values contained at those indices.
    i.indexValuePairs yields pairs of (index,value).  All of these
    share the same natural order.  It is necessary to define one
    of indices() and indexValuePairs(); the generator() is
    defined in terms of indexValuePairs().
  A set of utility functions, assign, fill, and copy.  Only fill and
    copy need to be defined.
**)
trait Indexed[\T extends Indexed[\T, E, I\], E, I\]
    extends { HasRank, Generator[\(I,E)\] }
  opr[i:I] : E
  opr[i:I]:=(v:E) : ()
  assign(v:T):T = fill(fn (i:I):E => v[i])
  fill(f:I->E):T
  fill(v:E):T = fill(fn (i:I):E => v)
  copy():T
  indices(): Generator[\I\] = self.map[\I\](fn (i:I, e:E): I => i)
  elements(): Generator[\E\] = self.map[\E\](fn (i:I, e:E): E => e)
end

(* Array whose bounds are implicit rather than static. *)
trait Array[\E,I\] extends Indexed[\Array[\E,I\],E,I\]
  getter size(): I
  getter base(): I
  replica[\U\]():Array[\U,I\]
end

(* Factory for arrays which returns an empty 0-indexed array of a given
   run-time-determined size. *)
array[\E\](x:ZZ32):Array[\E,ZZ32\] = __arr'(__Proxy[\E\](),reflect(x))
array[\E\](x:ZZ32,y:ZZ32):Array[\E,(ZZ32,ZZ32)\] =
   __arr'(__Proxy[\E\](),reflect(x), reflect(y))
array[\E\](x:ZZ32,y:ZZ32,z:ZZ32):Array[\E,(ZZ32,ZZ32,ZZ32)\] =
   __arr'(__Proxy[\E\](),reflect(x), reflect(y), reflect(z))

(* This should be local to array, but we don't support local
   parametric methods in the language spec at all at the moment. *)
__arr'[\E, nat n, nat m, nat p\](w:__Proxy[\E\],x:N[\n\]):Array1[\E,0,n\] =
   array1[\E,n\]()
__arr'[\E, nat n, nat m, nat p\](w:__Proxy[\E\],x:N[\n\],y:N[\m\]):
    Array2[\E,0,n,0,m\] = array2[\E,n,m\]()
__arr'[\E, nat n, nat m, nat p\](w:__Proxy[\E\],x:N[\n\],y:N[\m\],z:N[\p\]):
    Array3[\E,0,n,0,m,0,p\] = array3[\E,n,m,p\]()

(* Canonical partitioning of a positive number x into two pieces.  If
     (a,b) = partition(n)
   and n > 0 then 0 < a <= b,  n = a + b.
   As it turns out we choose a to be the largest power of 2 < n.
*)
partition(x:ZZ32):(ZZ32,ZZ32) = do
  m = partitionL(x)
  (m,x-m)
end

(** Array1[\T,b0,s0\] is a 1-dimension array whose s0 elements are of
    type T, and whose lowest index is b0.

    The natural order of all generators is from b0 to b0+s0-1. **)
trait Array1[\T, nat b0, nat s0\]
    extends { Indexed1 [\s0\], Rank1, Array[\T,ZZ32\],
              Indexed[\Array1[\T,b0,s0\],T,ZZ32\] }
    excludes {Number, String}
  getter size():ZZ32 = s0
  getter base():ZZ32 = b0
  getter toString() = do
    r = "[" b0 "#" s0 "] = ["
    if s0=0 then
      r "]"
    else
      f(i:ZZ32,t:T):String = " " t
      j(a:String,b:String) = a b
      r self.mapReduce[\String\](f,j,"") " ]"
    end
  end

  (* Get and put come from implementation.  They are always 0-indexed
     and unchecked. *)
  get(i:ZZ32):T
  put(v:T, i:ZZ32)

  indices():Range[\ZZ32\] = b0#s0

  (* Offset converts from b0 indexing to 0 indexing,
     bounds checking en route *)
  offset(i:ZZ32):ZZ32 = do
    r = i - b0
    if r >= s0 OR r < 0 then oops(1, b0, s0, i) end
    r
  end

  opr[i:ZZ32] : T = get(offset(i))
  opr[i:ZZ32]:=(v:T) : () = put(v, offset(i))

  subarray[\nat b, nat s, nat o\]():Array1[\T, b, s\] = do
    o0 : ZZ32 = o - b0
    if o0 < 0 OR o0 > s0-s then
        fail("Array1: subarray exceeds bounds of underlying array.")
    end
    __SimpleSubArray1[\T,b,s,b0,s0\](self,o0,1)
  end
  __subarray[\nat b, nat s, nat o\]
            (_:N[\b\],_:N[\o\],_:N[\s\]):Array1[\T,b,s\] = subarray[\b,s,o\]()

  opr[r:Range[\ZZ32\]]:Array[\T,ZZ32\] = do
      (b,s) = (reflect(r.base()), reflect(r.size()))
      self.__subarray(N[\0\],b,s)
    end
  opr[r:Range[\ZZ32\]]:=(v:Array[\T,ZZ32\]) = do self[r].assign(v); () end

  (* the replica method returns a replica of the array (similar layout
     etc.) but with a different element type. *)
  replica[\U\]():Array1[\U,b0,s0\] = __builtinFactory1[\U,b0,s0\]()

  assign(other:Array1[\T,b0,s0\]): Array1[\T,b0,s0\] =
      fill(fn (i:ZZ32): T => other.get(i-b0))

  generate[\R\](r: Reduction[\R\],m: (ZZ32,T)->R): R =
    ParRange[\ZZ32\](0,s0).generate[\R\](r, fn (i: ZZ32): R => m(b0+i,get(i)))

  seq(): SequentialGenerator[\(ZZ32,T)\] =
    SeqRange[\ZZ32\](0,s0).map[\(ZZ32,T)\](fn (i: ZZ32): (ZZ32,T) =>
                                              (b0+i,self.get(i)))

  fill(f:ZZ32->T):Array1[\T,b0,s0\] = do
    ParRange[\ZZ32\](0,s0).loop(fn (i: ZZ32): () => put(f(b0+i),i))
    self
  end

  copy():Array1[\T,b0,s0\] = replica[\T\]().assign(self)

  map[\R\](f:(ZZ32,T)->R): R =
      replica[\R\]().fill(fn (i:ZZ32):R => f(i,get(i-b0)))

  eq(o:Array1[\T,b0,s0\]):Boolean =
    generate[\Boolean\](AndReduction, fn (i: ZZ32,e: T): Boolean => e=o.get(i))
end

(* A 1-D subarray, defined wrt underlying FlatStorage.
   l0 is the underlying size, m0 the stride, and o0 the starting
   offset in the underlying FlatStorage.
   Invariant: (s0-1) m0 + o0 < l0 *)
object __SubArray1[\T, nat b0, nat s0, nat l0\]
       (mem:FlatStorageMaker[\T,l0\], o0:ZZ32, m0:ZZ32)
       extends Array1[\T, b0, s0\]
    index(i:ZZ32):T = i m0 + o0
    get(i:ZZ32):T = mem.get(index(i))
    put(v:T, i:ZZ32):T = mem.put(v,index(i))
    subarray[\nat b, nat s, nat o\]():Array1[\T, b, s\] = do
      o_n : ZZ32 = o - b0
      if o_n < 0 OR o_n > s0-s then
          fail("__SubArray1: subarray exceeds bounds of underlying array.")
      end
      __SubArray1[\T,b,s,l0\](mem,index(o_n),m0)
    end
end

(* A 1-D subarray of an Array1.
   b_a and s_a are the underlying array's bounds; s0 and b0 are the
   result bounds.  o0 is the starting offset in the underlying array,
   defined in 0-indexed space.  m0 the stride within that array.
   Invariant: (s0-1) m0 + o0 - b_a) < s_a *)
object __SimpleSubArray1[\T, nat b0, nat s0, nat b_a, nat s_a\]
       (arr:Array1[\T,b_a,s_a\], o0:ZZ32, m0:ZZ32)
       extends Array1[\T, b0, s0\]
    index(i:ZZ32):T = i m0 + o0
    get(i:ZZ32):T = arr.get(index(i))
    put(v:T,i:ZZ32): () = arr.put(v,index(i))
    subarray[\nat b, nat s, nat o\]():Array1[\T, b, s\] = do
      o_n : ZZ32 = o - b0
      if o_n < 0 OR o_n > s0-s then
        fail("__SimpleSubArray1: subarray exceeds bounds of underlying array.")
      end
      __SimpleSubArray1[\T, b, s, b_a, s_a\](arr, index(o_n), m0)
    end
end

object __DefaultArray1[\T, nat b0, nat s0\]() extends Array1[\T, b0, s0\]
  mem:FlatStorageMaker[\T, s0\] = FlatStorageMaker[\T, s0\]()
  get(i:ZZ32):T = mem.get(i)
  put(v:T, i:ZZ32) = mem.put(v,i)
  subarray[\nat b, nat s, nat o\]():Array1[\T, b, s\] = do
    o0 : ZZ32 = o - b0
    if o0 < 0 OR o0 > s0-s then
        fail("__DefaultArray1: subarray exceeds bounds of underlying array.")
    end
    __SubArray1[\T,b,s,s0\](mem,o0,1)
  end
end

trait Vector[\T extends Number, nat s0\] extends Array1[\T,0,s0\]
    add(v:Vector[\T,s0\]): Vector[\T,s0\] =
        map[\T\](fn (i:ZZ32, e: T):T => e + v.get(i))
    subtract(v:Vector[\T,s0\]): Vector[\T,s0\] =
        map[\T\](fn (i:ZZ32, e: T):T => e - v.get(i))
    negate(): Vector[\T,s0\] = map[\T\](fn (i:ZZ32, e: T):T => - e)
    scale(t: T): Vector[\T,s0\] = map[\T\](fn (i,v) => t v)
    pmul(v: Vector[\T,s0\]): Vector[\T,s0\] =
        map[\T\](fn (i:ZZ32, e: T):T => e v.get(i))
    dot(v: Vector[\T,s0\]): T =
        mapReduce[\T\](fn (i:ZZ32, me_i:T):T => me_i v.get(i),
                       fn (x,y)=>x+y,0)
end

object __DefaultVector[\T, nat s0\]() extends Vector[\T,s0\]
  mem: FlatStorageMaker[\T, s0\] = FlatStorageMaker[\T, s0\]()
  get(i:ZZ32):T = mem.get(i)
  put(v:T, i:ZZ32) = mem.put(v,i)
  replica[\U\]() = array1[\T,s0\]()
end

(* builtinFactory1 must be a non-overloaded 0-parameter factory for
   0-indexed 1-D arrays.  The type parameters are enshrined in
   LHSEvaluator.java and NonPrimitive.java; the factory name is
   enshrined in WellKnownNames.java.  There must be some factory,
   named in this file, with this type signature.  A similar thing is
   true for K-dimensional array types. *)
__builtinFactory1[\T, nat b0, nat s0\]():Array1[\T,b0,s0\] =
    if b0=0 then array1[\T,s0\]() else __DefaultArray1[\T,b0,s0\]() end

array1[\T, nat s0\]():Array1[\T,0,s0\] =
    typecase _ = __Proxy[\T\]() of
        __Proxy[\ZZ32\] => vector[\T,s0\]()
        __Proxy[\ZZ64\] => vector[\T,s0\]()
        __Proxy[\Integral\] => vector[\T,s0\]()
        __Proxy[\RR64\] => vector[\T,s0\]()
        __Proxy[\Number\] => vector[\T,s0\]()
        else => __DefaultArray1[\T,0,s0\]()
    end
array1[\T, nat s0\](v:T):Array1[\T,0,s0\] = array1[\T,s0\]().fill(v)
array1[\T, nat s0\](f:ZZ32->T):Array1[\T,0,s0\] = array1[\T,s0\]().fill(f)

(* vector is the same as array1, but specialized to numeric type arguments *)
vector[\T extends Number, nat s0\]():Vector[\T,s0\] = __DefaultVector[\T,s0\]()
vector[\T extends Number, nat s0\](v:T):Vector[\T,s0\] =
    vector[\T,s0\]().fill(v)
vector[\T extends Number, nat s0\](f:ZZ32->T):Vector[\T,s0\] =
    vector[\T,s0\]().fill(f)


opr +[\ T extends Number, nat n, nat m \]
     (me : Vector[\T,n\], other : Vector[\T,n\]):Vector[\T,n\] = me.add(other)

opr -[\ T extends Number, nat n, nat m \]
     (me : Vector[\T,n\], other : Vector[\T,n\]):Vector[\T,n\] =
    me.subtract(other)

opr -[\ T extends Number, nat n, nat m \]
     (me : Vector[\T,n\]):Vector[\T,n\] = me.negate()

pmul[\ T extends Number, nat k \]
    (a : Vector[\T,k\], b : Vector[\T,k\]):Vector[\T,k\] = a.pmul(b)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (me : Vector[\T,n\], other : Vector[\T,n\]):T = me.dot(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (me : Vector[\T,n\], other : Vector[\T,n\]):T = me.dot(other)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (me : Vector[\T,n\], other : T) : Vector[\T,n\] = me.scale(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (me : Vector[\T,n\], other : T) : Vector[\T,n\] = me.scale(other)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
        (other : T, me : Vector[\T,n\]) : Vector[\T,n\] = me.scale(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (other : T, me : Vector[\T,n\]) : Vector[\T,n\] = me.scale(other)

squaredNorm[\T extends Number, nat s0\](a:Vector[\T,s0\]):T = a.dot(a)

opr [\ T extends Number, nat k \]
    ||me : Vector[\T,k\]|| : RR64 = SQRT squaredNorm(me)

(** Array2[\T,b0,s0,b1,s1\] is the type of 2-dimensional arrays of
    element type T, with size s0 in the first dimension and s1 in the
    second dimension and lowest index (b0,b1).  Natural order for all
    generators in each dimension is from b to b+s-1; the overall order
    of elements need only be consistent with the cross product of
    these orderings (see Generator.cross()). **)
trait Array2[\T, nat b0, nat s0, nat b1, nat s1\]
    extends { Indexed1[\s0\], Indexed2[\s1\], Rank2, Array[\T,(ZZ32,ZZ32)\],
              Indexed[\Array2[\T,b0,s0,b1,s1\],T,(ZZ32,ZZ32)\] }
    excludes { Number, String }
  getter size():(ZZ32,ZZ32) = (s0,s1)
  getter base():(ZZ32,ZZ32) = (b0,b1)
  getter toString() = do
    r : String := "[" b0 "#" s0 "," b1 "#" s1 "] ="
    row(i) =
      for j <- sequential(0#s1) do
         r := r " " get(i,j)
      end
    if s0 = 0 then
      r " []"
    else
      r := r "\n["
      row(0)
      for i <- sequential(1#(s0-1)) do
        r := r "\n "
        row(i)
      end
      r " ]"
    end
  end
  (* Translate from b0,b1-indexing to 0-indexing, checking bounds. *)
  offset(a0:ZZ32,a1:ZZ32):(ZZ32,ZZ32) = do
    c0 = a0 - b0
    c1 = a1 - b1
    if c0 < 0 OR c0 >= s0 OR c1 < 0 OR c1 >= s1 then
      if c0 < 0 OR c0 >= s0 then
        oops(1,b0,s0,a0)
      else
        oops(2,b1,s1,a1)
      end
    end
    (c0,c1)
  end
  opr[t:(ZZ32,ZZ32)] : T = self.get(offset(t))
  opr[t:(ZZ32,ZZ32)]:=(v:T):() = do (i,j) = offset(t); self.put(v,i,j) end
  opr[x:ZZ32,y:ZZ32]:=(v:T):() = do (i,j) = offset(x,y); self.put(v,i,j) end
  indices(): Generator[\(ZZ32,ZZ32)\] =
      ParRange[\ZZ32\](b0,s0).cross[\ZZ32\](ParRange[\ZZ32\](b1,s1))
  fill(f:(ZZ32,ZZ32)->T):Array2[\T,b0,s0,b1,s1\] = do
      indices().loop(fn (a:ZZ32, b:ZZ32): () => put(f(a,b),a-b0, b-b1))
      self
    end
  replica[\U\]():Array2[\U,b0,s0,b1,s1\] =
      __builtinFactory2[\U,b0,s0,b1,s1\]()
  generate[\R\](r: Reduction[\R\], m: ((ZZ32,ZZ32),T)->R): R =
      ParRange[\ZZ32\](0,s0).cross[\ZZ32\](
          ParRange[\ZZ32\](0,s1)).generate[\R\](
              r, fn (a:ZZ32, b:ZZ32): R => m((a+b0,b+b1),get(a,b)))
  seq(): SequentialGenerator[\((ZZ32,ZZ32),T)\] =
      SeqRange[\ZZ32\](0,s0).cross[\ZZ32\](
          SeqRange[\ZZ32\](0,s1)).map[\((ZZ32,ZZ32),T)\](
              fn (a:ZZ32, b:ZZ32): ((ZZ32,ZZ32),T)=>((a+b0,b+b1),self.get(a,b)))
  copy():Array2[\T,b0,s0,b1,s1\] = self.replica[\T\]().assign(self)
  put(v:T, i:ZZ32, j:ZZ32) : ()
  get(i:ZZ32, j:ZZ32):T
  t():Array2[\T,b1,s1,b0,s0\] = TransposedArray2[\T,b1,s1,b0,s0\](self)
  (* Copied here from Indexed, for better return type information. *)
  assign(other: Array2[\T,b0,s0,b1,s1\]): Array2[\T,b0,s0,b1,s1\] =
      fill(fn (i:ZZ32,j:ZZ32) => other.get(i-b0,j-b1))
  fill(v:T):Array2[\T,b0,s0,b1,s1\] = fill(fn (i:ZZ32,j:ZZ32):T => v)
  map[\R\](f:((ZZ32,ZZ32),T)->R): R =
      replica[\R\]().fill(fn (i:ZZ32,j:ZZ32):R => f((i,j),get(i-b0,j-b1)))
  eq(o:Array2[\T,b0,s0,b1,s1\]):Boolean =
    generate[\Boolean\](AndReduction,
                        fn (i:(ZZ32,ZZ32),e:T): Boolean => e = o.get(i))
end

(** Default array is column-major, but we could switch it. **)
object __DefaultArray2[\T, nat b0, nat s0, nat b1, nat s1\]()
    extends Array2[\T, b0, s0, b1, s1\]
  mem:FlatStorageMaker[\T, (s0 s1) \] = FlatStorageMaker[\T, (s0 s1) \]()
  put(v:T, i:ZZ32, j:ZZ32) : () = mem.put(v, i s1 + j)
  get(i:ZZ32, j:ZZ32):T = mem.get(i s1 + j)
end

(** Transposes the index of the underlying array mem, and transposes
    its natural order as well. **)
object TransposedArray2[\T, nat b0, nat s0, nat b1, nat s1\]
                       (mem:Array2[\T,b1,s1,b0,s0\])
    extends Array2[\T, b0, s0, b1, s1\]
  replica[\U\]():Array2[\U,b0,s0,b1,s1\] = mem.replica[\U\]().t()

  put(v:T, i:ZZ32, j:ZZ32) : () = mem.put(v,j,i)
  get(i:ZZ32, j:ZZ32):T = mem.get(j,i)
  t() = mem
end

trait Matrix[\T, nat s0, nat s1\] extends Array2[\T, 0, s0, 0, s1\]
    add(v:Matrix[\T,s0,s1\]): Matrix[\T,s0,s1\] =
(*   This version of the code breaks horribly.
        map[\T\](fn (i:(ZZ32,ZZ32),e:T):T => e + v.get i)
*)
        map[\T\](fn (i:(ZZ32,ZZ32),e:T):T => e + v.get(i))
    subtract(v:Matrix[\T,s0,s1\]): Matrix[\T,s0,s1\] =
        map[\T\](fn (i:(ZZ32,ZZ32),e:T):T => e - v.get(i))
    negate(): Matrix[\T,s0,s1\] =
        map[\T\](fn (i:(ZZ32,ZZ32),e:T):T => - e)
    scale(t: T): Matrix[\T,s0,s1\] =
        map[\T\](fn (i:(ZZ32,ZZ32),e:T):T => t e)
    mul[\ nat s2 \](other: Matrix[\T,s1,s2\]): Matrix[\T,s0,s2\] = do
        res = matrix[\T,s0,s2\]()
        mma(a:ZZ32,i:ZZ32,b:ZZ32,j:ZZ32,c:ZZ32,k:ZZ32):() =
            if k>=i AND k>=j then
              if k=1 then
                pr : T = get(a,b) other.get(b,c)
                (* If this were atomic, we could parallelize j-partition. *)
                res.put(res.get(a,c) + pr, a, c)
              else
                (k0,k1) = partition(k)
                (mma(a,i,b,j,c,k0),mma(a,i,b,j,c+k0,k1))
              end
            elif j>=i then
                (j0,j1) = partition(j)
                mma(a,i,b,j0,c,k)
                mma(a,i,b+j0,j1,c,k)
            else
                (i0,i1) = partition(i)
                (mma(a,i0,b,j,c,k),mma(a+i0,i1,b,j,c,k))
            end
        mm(a:ZZ32,i:ZZ32,b:ZZ32,j:ZZ32,c:ZZ32,k:ZZ32):() =
            if k>=i AND k>=j then
              if k=1 then
                res.put(get(a,b) other.get(b,c), a, c)
              else
                (k0,k1) = partition(k)
                (mm(a,i,b,j,c,k0),mm(a,i,b,j,c+k0,k1))
              end
            elif j>=i then
                (j0,j1) = partition(j)
                mm(a,i,b,j0,c,k)
                mma(a,i,b+j0,j1,c,k)
            else
                (i0,i1) = partition(i)
                (mm(a,i0,b,j,c,k),mm(a+i0,i1,b,j,c,k))
            end
        if s0=0 OR s1=0 OR s2=0 then
          res
        else
          mm(0,s0,0,s1,0,s2)
          res
        end
      end
    rmul(v: Vector[\T,s1\]): Vector[\T,s0\] = do
        row(i:ZZ32):T = v.mapReduce[\T\](fn (j:ZZ32, v_j):T => get(i,j) v_j,
                                         fn (a,b)=> a+b, 0)
        vector[\T,s0\]().fill(row)
      end
    lmul(v: Vector[\T,s0\]): Vector[\T,s1\] = do
        col(i:ZZ32):T = v.mapReduce[\T\](fn (j:ZZ32, v_j) => v_j get(j,i),
                                         fn (a,b)=> a+b, 0)
        vector[\T,s1\]().fill(col)
      end
    t(): Matrix[\T,s1,s0\] = TransposedMatrix[\T,s1,s0\](self)
end

(* Default matrix should match default array in column vs row-major. *)
object __DefaultMatrix[\T, nat s0, nat s1\]()
    extends Matrix[\T, s0, s1\]
  mem:FlatStorageMaker[\T, (s0 s1) \] = FlatStorageMaker[\T, (s0 s1) \]()
  put(v:T, i:ZZ32, j:ZZ32) : () = mem.put(v, i s1 + j)
  get(i:ZZ32, j:ZZ32):T = mem.get(i s1 + j)
end

object TransposedMatrix[\T, nat s0, nat s1\](mem:Matrix[\T,s1,s0\])
        extends Matrix[\T, s0, s1\]
    replica[\U\]():Array2[\U,0,s0,0,s1\] = mem.replica[\U\]().t()

    put(v:T, i:ZZ32, j:ZZ32) : () = mem.put(v,j,i)
    get(i:ZZ32, j:ZZ32):T = mem.get(j,i)
    t(): Matrix[\T,s1,s0\] = mem
    add(v:TransposedMatrix[\T,s0,s1\]): Matrix[\T,s0,s1\] = mem.add(v.t()).t()
    subtract(v:Matrix[\T,s0,s1\]): Matrix[\T,s0,s1\] = mem.subtract(v.t()).t()
    negate(): Matrix[\T,s0,s1\] = mem.negate().t()
    scale(f: T): Matrix[\T,s0,s1\] = mem.scale(f).t()
    rmul(v: Vector[\T,s1\]): Vector[\T,s0\] = mem.lmul(v)
    lmul(v: Vector[\T,s0\]): Vector[\T,s1\] = mem.rmul(v)
(*  Can't overload generic methods yet, but this is preferable.
    mul[\nat s2\](v:TransposedMatrix[\T,s1,s2\]): Matrix[\T,s0,s2\] =
        v.t().mul(mem).t()
*)
end

__builtinFactory2[\T,nat b0,nat s0,nat b1,nat s1\]():Array2[\T,b0,s0,b1,s1\] =
    if b0=0 AND b1=0 then
        array2[\T,s0,s1\]()
    else
        __DefaultArray2[\T,b0,s0,b1,s1\]()
    end

(* array2 is a factory for 0-based 2-D arrays. *)
array2[\T, nat s0, nat s1\]():Array2[\T,0,s0,0,s1\] =
    typecase _ = __Proxy[\T\]() of
        __Proxy[\ZZ32\] => matrix[\T,s0,s1\]()
        __Proxy[\ZZ64\] => matrix[\T,s0,s1\]()
        __Proxy[\Integral\] => matrix[\T,s0,s1\]()
        __Proxy[\RR64\] => matrix[\T,s0,s1\]()
        __Proxy[\Number\] => matrix[\T,s0,s1\]()
        else => __DefaultArray2[\T,0,s0,0,s1\]()
    end
array2[\T, nat s0, nat s1\](v:T):Array2[\T,0,s0,0,s1\] =
  array2[\T,s0,s1\]().fill(v)
array2[\T, nat s0, nat s1\](f:(ZZ32,ZZ32)->T):Array2[\T,0,s0,0,s1\] =
  array2[\T,s0,s1\]().fill(f)

(* matrix is the same as array1, but specialized to numeric type
   arguments, except that the default value (if given) is used to
   construct a multiple of the identity matrix. *)
matrix[\T extends Number, nat s0, nat s1\]():Matrix[\T,s0,s1\] =
  __DefaultMatrix[\T,s0,s1\]()
matrix[\T extends Number, nat s0, nat s1\](v:T):Matrix[\T,s0,s1\] =
  array2[\T,s0,s1\]().fill(fn (x:ZZ32,y:ZZ32):T => if x=y then v else 0 end)

opr +[\ T extends Number, nat n, nat m \]
     (me:Matrix[\T,n,m\], other:Matrix[\T,n,m\]): Matrix[\T,n,m\] =
        me.add(other)

opr -[\ T extends Number, nat n, nat m \]
     (me:Matrix[\T,n,m\], other:Matrix[\T,n,m\]) : Matrix[\T,n,m\] =
        me.subtract(other)

opr -[\ T extends Number, nat n, nat m \]
     (me:Matrix[\T,n,m\]): Matrix[\T,n,m\] =
        me.negate()

(* Matrix multiplication; used to use a cache-oblivious algorithm, but
   we ran into trouble due to lack of support for atomic increment of
   matrix elements. *)
opr DOT[\ T extends Number, nat n, nat m, nat p\]
       (me:Matrix[\T,n,m\], other:Matrix[\T,m,p\]): Matrix[\T,n,p\] =
        me.mul[\p\](other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p\]
     (me:Matrix[\T,n,m\], other:Matrix[\T,m,p\]): Matrix[\T,n,p\] =
        me.mul[\p\](other)


(* matrix-vector multiplication *)
opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (me:Matrix[\T,n,m\], v:Vector[\T,m\]):Vector[\T,n\] = me.rmul(v)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (me:Matrix[\T,n,m\], v:Vector[\T,m\]):Vector[\T,n\] = me.rmul(v)

(* vector-matrix multiplication *)
opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (v:Vector[\T,n\], me:Matrix[\T,n,m\]):Vector[\T,m\] = me.lmul(v)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (v:Vector[\T,n\], me:Matrix[\T,n,m\]):Vector[\T,m\] = me.lmul(v)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (me : Matrix[\T,n,m\], other : T) : Matrix[\T,n,m\] = me.scale(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (me : Matrix[\T,n,m\], other : T) : Matrix[\T,n,m\] = me.scale(other)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (other : T, me : Matrix[\T,n,m\]) : Matrix[\T,n,m\] = me.scale(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (other : T, me : Matrix[\T,n,m\]) : Matrix[\T,n,m\] = me.scale(other)

(* Helper function for Array3 *)
flat3[\A,B,C\](t:(A,B), c:C): (A,B,C) = do (a,b) = t; (a,b,c) end

(** Array3[\T,b0,s0,b1,s1,b2,s2\] is the type of 3-dimensional arrays
    of element type T, with size s_i in the i^th dimension and lowest
    index (b0,b1,b2).  Natural order for all generators in each
    dimension is from b to b+s-1; the overall order of elements need
    only be consistent with the cross product of these orderings (see
    Generator.cross()). **)
trait Array3[\T, nat b0, nat s0, nat b1, nat s1, nat b2, nat s2\]
  extends { Indexed1 [\s0\], Indexed2 [\s1\], Indexed3 [\s2\], Rank3,
            Array[\T,(ZZ32,ZZ32,ZZ32)\],
            Indexed[\Array3[\T,b0,s0,b1,s1,b2,s2\],T,(ZZ32,ZZ32,ZZ32)\] }
  excludes { Number, String }

  getter size():(ZZ32,ZZ32,ZZ32) = (s0,s1,s2)
  getter base():(ZZ32,ZZ32,ZZ32) = (b0,b1,b2)

  getter toString():String = do
    r : String := "[" b0 "#" s0 "," b1 "#" s1 "," b2 "#" s2 "] ="
    row(i,j) =
        for k <- sequential(0#s2) do
          r := r " " get(i,j,k)
        end
    plane(i) =
      if s1 > 0 then
        for j <- sequential(0#(s1-1)) do
          row(i,j)
        end
      end
    if s0=0 then
      r " []"
    else
      r := r "\n[ "
      plane(0)
      for i <- sequential(1#(s0-1)) do
        r := r ";;\n  "
        plane(i)
      end
      r " ]"
    end
  end

  (* Again, offset performs bounds checking and shifts to 0 indexing. *)
  offset(a0:ZZ32,a1:ZZ32,a2:ZZ32):(ZZ32,ZZ32,ZZ32) = do
    c0 = a0 - b0; c1 = a1 - b1; c2 = a2 - b2
    if c0 >= s0 OR c0 < 0 then oops(1, b0, s0, a0); end
    if c1 >= s1 OR c1 < 0 then oops(2, b1, s1, a1); end
    if c2 >= s2 OR c2 < 0 then oops(3, b2, s2, a2); end
    (c0,c1,c2)
  end

  (* And get and put are 0-indexed without bounds checks. *)
  put(v:T, i:ZZ32, j:ZZ32, k:ZZ32) : ()
  get(i:ZZ32, j:ZZ32, k:ZZ32) : T

  opr[t:(ZZ32, ZZ32, ZZ32)] : T = self.get(offset(t))
  (* opr[i:ZZ32, j:ZZ32, k:ZZ32] : T = self.get(offset(i,j,k)) *)
  opr[t:(ZZ32,ZZ32,ZZ32)] := (v:T) = do (a,b,c)=offset(t); self.put(v,a,b,c) end
  opr[i:ZZ32, j:ZZ32, k:ZZ32] := (v:T) = do
    (a,b,c) = offset(i,j,k)
    self.put(v,a,b,c)
  end

  indices():Generator[\(ZZ32,ZZ32,ZZ32)\] = do
      g0 = ParRange[\ZZ32\](b0,s0)
      g1 = ParRange[\ZZ32\](b1,s1)
      g2 = ParRange[\ZZ32\](b2,s2)
      m(i:ZZ32,jk:(ZZ32,ZZ32)):(ZZ32,ZZ32,ZZ32) = do (j,k) = jk; (i,j,k) end
      g0.cross(g1.cross(g2)).map(m)
    end

  generate[\R\](r:Reduction[\R\], m:((ZZ32,ZZ32,ZZ32),T)->R): R = do
      g0 = ParRange[\ZZ32\](0,s0)
      g1 = ParRange[\ZZ32\](0,s1)
      g2 = ParRange[\ZZ32\](0,s2)
      mm(i:ZZ32,jk:(ZZ32,ZZ32)):(ZZ32,ZZ32,ZZ32) = do
          (j,k) = jk
          m((b0+i,b1+j,b2+k),get(i,j,k))
        end
      g0.cross(g1.cross(g2)).generate[\R\](r,mm)
    end

  seq(): SequentialGenerator[\((ZZ32,ZZ32,ZZ32),T)\] = do
      g0 = SeqRange[\ZZ32\](0,s0)
      g1 = SeqRange[\ZZ32\](0,s1)
      g2 = SeqRange[\ZZ32\](0,s2)
      mm(i:ZZ32,jk:(ZZ32,ZZ32)):(ZZ32,ZZ32,ZZ32) = do
          (j,k) = jk
          ((b0+i,b1+j,b2+k),get(i,j,k))
        end
      g0.cross(g1.cross(g2)).map[\((ZZ32,ZZ32,ZZ32),T)\](mm)
    end

  fill(f:(ZZ32,ZZ32,ZZ32)->T):Array3[\T,b0,s1,b1,s1,b2,s2\] = do
    indices().loop(fn (i:ZZ32,j:ZZ32,k:ZZ32):() => put(f(i,j,k),i-b0,j-b0,k-b0))
    self
  end
  replica[\U\]():Array3[\T,b0,s0,b1,s1,b2,s2\]
  copy():Array3[\T,b0,s0,b1,s1,b2,s2\] = self.replica[\T\]().assign(self)
  assign(v:Array3[\T,b0,s0,b1,s1,b2,s2\]) =
      fill(fn (i:ZZ32,j:ZZ32,k:ZZ32):T =>
               put(v.get(i-b0,j-b1,k-b2),i-b0,j-b1,k-b2))
  map[\R\](f:((ZZ32,ZZ32,ZZ32),T)->R): R =
      replica[\R\]().fill(fn (i:ZZ32,j:ZZ32,k:ZZ32):R =>
                              f((i,j,k),get(i-b0,j-b1,k-b2)))
  eq(o:Array3[\T,b0,s0,b1,s1,b2,s2\]):Boolean =
      generate[\Boolean\](AndReduction,
                          fn (i:(ZZ32,ZZ32,ZZ32),e:T) => e = o[i])
end

object __DefaultArray3[\T, nat b0, nat s0, nat b1, nat s1, nat b2, nat s2\]() extends
                                        Array3[\T, b0, s0, b1, s1, b2, s2\]
  mem:FlatStorageMaker[\T,(s0 (s1 s2))\] = FlatStorageMaker[\T,(s0 (s1 s2))\]()

  ofs = s1 s2

  replica():Array3[\T,b0,s0,b1,s1,b2,s2\] =
      __DefaultArray3[\T,b0,s0,b1,s1,b2,s2\]()
  put(v:T, i:ZZ32, j:ZZ32, k:ZZ32) : () = mem.put(v, i ofs + j s2 + k)
  get(i:ZZ32, j:ZZ32, k:ZZ32) : T = mem.get(i ofs + j s2 + k)
end

__builtinFactory3[\T, nat b0, nat s0, nat b1, nat s1, nat b2, nat s2\]():
        Array3[\T,b0,s0,b1,s1,b2,s2\] =
  __DefaultArray3[\T,b0,s0,b1,s1,b2,s2\]()

array3[\T,nat s0, nat s1, nat s2\]():Array3[\T,0,s0,0,s1,0,s2\] =
  __DefaultArray3[\T,0,s0,0,s1,0,s2\]()

(*************

trait Monoid[\ T, opr OPLUS \]
  where { T extends Monoid[\ T, OPLUS \] }
    zero() : T
    opr OPLUS(self, other:T):T
end

*************)

(* Simple mockup of Generators and Reductions. *)

(* The reduction traits allow us to define systematic
recursively-decomposed computations in the absence of a real Generator
hierarchy.  The simplest instance of a reduction defines two functions:
  empty -- What to do if we reach an empty portion of a structure
  join  -- How to combine two pieces of a structure if we don't care which dimension it was split in.
*)

trait Reduction[\ R \]
    getter toString() = "A Reduction without a toString() of its own"
    empty(): R
    join(a: R, b: R): R
end

object VoidReduction extends Reduction[\()\]
    getter toString() = "VoidReduction"
    empty(): () = ()
    join(a: (), b: ()): () = ()
end

object SumReduction[\N extends Number\]() extends Reduction[\N\]
    getter toString() = "SumReduction"
    empty(): N = 0
    join(a: N, b: N): N = a+b
end

(** TODO: AndReduction and OrReduction have natural zeros, and could
 *  take advantage of early exit.
 *
 *  In the absence of full algebraic fanciness, we might still use
 *  label/exit on a thunked domain to achieve the same effect, in
 *  effect pushing the control into the reduction operator itself.
 *)

object AndReduction extends Reduction[\Boolean\]
    getter toString() = "AndReduction"
    empty(): Boolean = true
    join(a: Boolean, b: Boolean): Boolean = a AND b
end

object OrReduction extends Reduction[\Boolean\]
    getter toString() = "OrReduction"
    empty(): Boolean = false
    join(a: Boolean, b: Boolean): Boolean = a OR b
end

object StringReduction extends Reduction[\String\]
    getter toString() = "StringReduction"
    empty(): Boolean = ""
    join(a:String, b:String): String = a b
end

object MapReduceReduction[\R\](j:(R,R)->R, z:R) extends Reduction[\R\]
    getter toString()="mapReduce.Reduction"
    empty() = z
    join(a:R, b:R): R = j(a,b)
end

(** Helpers for maps and cross products of generators.  These can be
    quite a bit more sophisticated (for example, we can hoist maps
    outwards if we think that'd be useful), but let's get this much
    working first. *)

object SimpleMappedGenerator[\E,F\](g: Generator[\E\], f: E->F)
        extends Generator[\F\]
    getter size(): ZZ32 = g.size()
    getter toString() = g ".map(f)"
    generate[\R\](r: Reduction[\R\], m: F->R): R =
        g.generate[\R\](r, m COMPOSE f)
    reduce(r: Reduction[\F\]): F =
        g.generate[\R\](r, f)
    map[\G\](f': F->G): SimpleMappedGenerator[\E,G\] =
        SimpleMappedGenerator[\E,G\](g, f' COMPOSE f)
    seq() = SimpleMappedGenerator[\E,F\](sequential(g),f)
end

object SimplePairGenerator[\E,F\](e: Generator[\E\], f: Generator[\F\])
        extends Generator[\(E,F)\]
    getter size() = e.size() f.size()
    getter toString()=(e ".cross(" f ")" )
    generate[\R\](r: Reduction[\R\], m:(E,F)->R): R =
        e.generate[\R\](r, fn (a: E): R =>
                              f.generate[\R\](r, fn (b: F): R => m(a,b)))
    seq() = SimplePairGenerator[\E,F\](sequential(e),seqential(f))
end

(** Helper for serializing generators naively.  This code should make
 *  obvious that naive seq is *VERY INEFFICIENT*.  It
 *  constructs a function closure whose size is proportional to
 *  g.size(), and then executes that closure.  This trick is old hat
 *  to lambda-calculus wonks, but pretty unfamiliar to the common man.
 *
 *  Basically each element takes in the accumulated value a from the element
 *  to its left.  This is joined with the result of mapping on the
 *  current element value, and that result is returned.  Join simply
 *  reverse-composes the functions for its subtrees, so the output of the left
 *  subtree is fed to the right subtree.
 *
 *  Note that a similar trick can be used to reverse and sequentialize
 *  a generator (use forward function composition rather than reverse
 *  composition, and flipping around the join at the leaves). *)

object NaiveSeqGenerator[\E\](g: Generator[\E\])
        extends SequentialGenerator[\E\]
    size() = g.size()
    toString() = "sequential(" g.toString() ")"
    generate[\R\](r: Reduction[\R\], m:E->R): R = do
      rcompose(f:R->R, g:R->R): R->R = fn (x:R):R => g(f(x))
      id(x:R):R = x
      mp(x:E):R->R = fn (a:R):R => r.join(a,m(x))
      f : R -> R = g.mapReduce[\R->R\](mp,rcompose,id)
      mt : R = r.empty()
      f mt
    end
end

(** ParRanges and SeqRanges, the simplest and most basic of all
generators.  They generate size() numbers, incrementing by 1, starting
with base() (that's the canonical ordering). *)
trait Range[\N extends Number\] extends Generator[\N\]
    getter size():N
    getter base():N
end
opr IN[\E\](x: E, r: Range[\E\]): Boolean = do
        b = r.base()
        b <= x AND (x-b < r.size())
    end

object ParRange[\N extends Number\](lo:N, sz:N)
        extends Range[\N\]
    getter size() = narrow(|\sz/|) MAX 0
    getter base() = lo
    getter toString()= lo "#" sz
    generate[\R\](r: Reduction[\R\], m: N->R): R =
        if sz < 1 then
            r.empty()
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           r.join(gen(l,s1),gen(l+s1,s2))
                       else
                           m(l)
                       end
            gen(lo,narrow |\sz/|)
        end
    seq() = SeqRange[\N\](base(),size())

    mapReduce[\R\](m: N->R, j:(R,R)->R, z:R): R =
        if sz < 1 then
            z
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           j(gen(l,s1),gen(l+s1,s2))
                       else
                           m(l)
                       end
            gen(lo,narrow |\sz/|)
        end
    reduce(j:(N,N)->N, z:N):N =
        if sz < 1 then
            z
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           j(gen(l,s1),gen(l+s1,s2))
                       else
                           l
                       end
            gen(lo,narrow |\sz/|)
        end
    reduce(r: Reduction[\N\]):N =
        if sz < 1 then
            r.empty()
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           r.join(gen(l,s1),gen(l+s1,s2))
                       else
                           l
                       end
            gen(lo,narrow |\sz/|)
        end
    loop(f:N->()): () =
        if sz < 1 then
            ()
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           (gen(l,s1),gen(l+s1,s2))
                           ()
                       else
                           f(l)
                       end
            gen(lo,narrow |\sz/|)
        end
end
object SeqRange[\N extends Number\](lo:N, sz:N)
        extends { Range[\N\], SequentialGenerator[\N\] }
    getter size() = sz
    getter base() = lo
    getter toString() = "seq(" lo "#" sz ")"
    generate[\R\](r: Reduction[\R\], m: N->R): R = do
        h = lo + sz
        l : N := lo
        acc : R = r.empty()
        (* DO NOT DEFINE THIS USING RECURSION!!! *)
        while l < h do
            acc := r.join(acc, m(l))
            l += 1
        end
        acc
      end
    loop(f: N->()): () = do
        h = lo + sz
        l : N := lo
        (* DO NOT DEFINE THIS USING RECURSION!!! *)
        while l < h do
            f(l)
            l += 1
        end
      end
end

(** The # and : operators serve as factories for parallel ranges. **)
opr #(lo:ZZ32, sz:ZZ32): Range[\ZZ32\] = ParRange[\ZZ32\](lo,sz)
opr #(lo:ZZ64, sz:ZZ64): Range[\ZZ64\] = ParRange[\ZZ64\](lo,sz)
opr #(lo:RR64, sz:RR64): Range[\RR64\] = ParRange[\RR64\](lo,sz)

opr :(lo:ZZ32, hi:ZZ32): Range[\ZZ32\] = ParRange[\ZZ32\](lo,hi-lo+1)
opr :(lo:ZZ64, hi:ZZ64): Range[\ZZ64\] = ParRange[\ZZ64\](lo,hi-lo+1)
opr :(lo:RR64, hi:RR64): Range[\RR64\] = ParRange[\RR64\](lo,hi-lo+1)

(***********************************************************
 * NUMERIC primitives, down here to avoid ordering hosure. *)

opr [\ N extends Number \]|x:N| = if x>=0 then x else -x end

opr -(a:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Negate")
opr +(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Add")
opr -(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Sub")
opr DOT(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Mul")
opr juxtaposition
     (a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Mul")
opr DIV(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Div")
opr REM(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Rem")
opr MOD(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Mod")
opr GCD(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Gcd")
opr LCM(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Lcm")
opr CHOOSE(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Choose")
opr BITAND(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$BitAnd")
opr BITOR(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$BitOr")
opr BITXOR(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$BitXor")
opr LSHIFT(a:ZZ32,b:Integral):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$LShift")
opr RSHIFT(a:ZZ32,b:Integral):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$RShift")
opr BITNOT(a:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$BitNot")
opr =(a:ZZ32, b:ZZ32):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Eq")
opr <=(a:ZZ32, b:ZZ32):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$LessEq")
opr MIN(a:ZZ32, b:ZZ32):ZZ32 = if a <= b then a else b end
opr MAX(a:ZZ32, b:ZZ32):ZZ32 = if b <= a then a else b end
opr ^(a:ZZ32, b:Integral):Number = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Pow")
widen(a:ZZ32):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$ToLong")
partitionL(a:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Partition")

nanoTime():ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$NanoTime")
printTaskTrace():() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$PrintTaskTrace")

__globalTimeInformation: ZZ64 := 0
recordTime(dummy: Any): () = do __globalTimeInformation := nanoTime() end
printTime(dummy: Any): () = do
    r = nanoTime()
    e = r - __globalTimeInformation
    __globalTimeInformation := r
    secs: ZZ64 = (e+500000) DIV 1000000
    println("Operation took " secs "ms")
  end

opr -(a: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Negate")
opr +(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Add")
opr -(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Sub")
opr DOT(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Mul")
opr juxtaposition
     (a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Mul")
opr DIV(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Div")
opr REM(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Rem")
opr MOD(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Mod")
opr GCD(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Gcd")
opr LCM(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Lcm")
opr CHOOSE(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Choose")
opr BITAND(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$BitAnd")
opr BITOR(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$BitOr")
opr BITXOR(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$BitXor")
opr LSHIFT(a: IntLiteral,b:Integral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$LShift")
opr RSHIFT(a: IntLiteral,b:Integral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$RShift")
opr BITNOT(a: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$BitNot")
opr =(a: IntLiteral, b: IntLiteral):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Eq")
opr <=(a: IntLiteral, b: IntLiteral):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$LessEq")
opr MIN(a: IntLiteral, b: IntLiteral): IntLiteral = if a <= b then a else b end
opr MAX(a: IntLiteral, b: IntLiteral): IntLiteral = if b <= a then a else b end
opr ^(a: IntLiteral, b:Integral):Number = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Pow")

opr -[\ T extends Number, nat n, nat m \]
     (a:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Negate")
opr +[\ T extends Number, nat n, nat m \]
     (a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Add")
opr -[\ T extends Number, nat n, nat m \]
     (a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Sub")
opr DOT[\ T extends Number, nat n, nat m, nat p \]
     (a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Mul")
opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Mul")
opr DIV(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Div")
opr REM(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Rem")
opr MOD(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Mod")
opr GCD(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Gcd")
opr LCM(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Lcm")
opr CHOOSE(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Choose")
opr BITAND(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$BitAnd")
opr BITOR(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$BitOr")
opr BITXOR(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$BitXor")
opr LSHIFT(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$LShift")
opr RSHIFT(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$RShift")
opr BITNOT(a:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$BitNot")
opr =(a:Integral, b:Integral):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Eq")
opr <=(a:Integral, b:Integral):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$LessEq")
opr MIN(a:Integral, b:Integral):ZZ64 = if a <= b then a else b end
opr MAX(a:Integral, b:Integral):ZZ64 = if b <= a then a else b end
opr ^(a:ZZ64, b:Integral):Number = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Pow")
narrow(a:ZZ64):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$FromLong")

opr   <(a:Integral, b:Integral):Boolean = NOT (b <= a)
opr   >(a:Integral, b:Integral):Boolean = NOT (a <= b)
opr  >=(a:Integral, b:Integral):Boolean = b <= a

opr -(a:RR64):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Negate")
opr +(a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Add")
opr -(a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Sub")
opr DOT(a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Mul")
opr juxtaposition
     (a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Mul")
opr /(a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Div")
opr =(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Eq")
opr =/=(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$NEq")
opr <(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Less")
opr <=(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$LessEq")
opr >(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Greater")
opr >=(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$GreaterEq")
opr MIN(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Min")
opr MAX(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Max")
opr |a:RR64|:RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Abs")
opr ^(a:Number, b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Pow")
opr SQRT(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Sqrt")
sin(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Sin")
cos(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Cos")
tan(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Tan")
asin(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ASin")
acos(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ACos")
atan(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ATan")
atan2(y:Number,x:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ATan2")
log(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Log")
exp(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Exp")
floor(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Floor")
opr |\a:Number/|:ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$IFloor")
ceiling(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Ceiling")
opr |/a:Number\|:ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ICeiling")
truncate(a:Number):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Truncate")
random(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Random")
opr |x:ZZ64|:ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Abs")

opr DOT(a:String, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:String, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:Number, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:Number, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:String, b:Number):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:String, b:Number):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:Boolean, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:Boolean, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:String, b:Boolean):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:String, b:Boolean):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:String, b:()):String = a "()"
opr juxtaposition(a:String, b:()):String = a "()"
opr DOT(a:(), b:String):String = "()" b
opr juxtaposition(a:(), b:String):String = "()" b
opr DOT(a:Any, b:String):String = a.toString() b
opr juxtaposition(a:Any, b:String):String = a.toString() b
opr DOT(a:String, b:Any):String = a b.toString()
opr juxtaposition(a:String, b:Any):String = a b.toString()

opr =(a:String, b:String):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Eq")
opr <(a:String, b:String):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Less")
opr <=(a:String, b:String):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$LessEq")
opr >(a:String, b:String):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Greater")
opr >=(a:String, b:String):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$GreaterEq")

(* buffed read/write supporting utf8 characters *)
inFileOpen(name:String):BufferedReader = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.File$InFileOpen")
inFileRead(file: BufferedReader):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.File$InFileRead")
inFileClose(file: BufferedReader):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.File$InFileClose")

outFileOpen(name:String):BufferedWriter = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.File$OutFileOpen")
outFileWrite(file: BufferedWriter, str: String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.File$OutFileWrite")
outFileClose(file: BufferedWriter):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.File$OutFileClose")

substring(str: String, beginIndex: ZZ32, endIndex: ZZ32):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Substring")
length(str: String):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Length")

print(a:String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Print")
println(a:String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Println")
print(a:Number):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Print")
println(a:Number):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Println")
print(a:Boolean):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Print")
println(a:Boolean):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Println")
print(a:Any):() = print("" a)
println(a:Any):() = println("" a)
(* 0-argument versions handle passing of () to single-argument versions. *)
print():() = print("()")
println():() = println("")

(* These are useful temporary hacks for debugging multi-threaded programs *)
printThreadInfo(a:String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$PrintThreadInfo")
printThreadInfo(a:Number):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$PrintThreadInfo")
throwError(a:String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$ThrowError")


opr  OR(a:Boolean, b:Boolean):Boolean = if a then true else b end
opr AND(a:Boolean, b:Boolean):Boolean = if a then b else false end
opr NOT(a:Boolean):Boolean = if a then false else true end
opr =(a:Boolean, b:Boolean):Boolean = if a then b else NOT b end
opr ->(a: Boolean, b:Boolean):Boolean = if a then b else true end
opr <->(a: Boolean, b:Boolean):Boolean = a=b
opr +[\T extends Number\](x:T):T = x

end
