/*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

generateEmptyConstructor yes;   // for reflective object creation
visitMethod accept;
visitorMethodPrefix for;
addGetterPrefixes yes;
usePLT yes;
tabSize 4;
allowNulls no;
generateToString no;
generateEquals yes;
generateSerializers yes;

package com.sun.fortress.nodes;
import java.io.IOException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import com.sun.fortress.nodes_util.*;
import com.sun.fortress.useful.*;

begin ast;

/**
 * top-level node interface
 */
interface Node();
    /**
     * declaration in components or APIs
     */
    interface AbsDeclOrDecl() extends HasAt;
        /**
         * declaration in APIs
         */
        interface AbsDecl();
        /**
         * declaration in components
         */
        interface Decl();
    /**
     * left-hand-side of assignments, local variable declarations, or
     * top-level declarations.
     */
    interface LHS();
/**
 * functional declaration or function expression
 */
interface Applicable(FnName fnName, Option<List<StaticParam>> staticParams,
                     List<Param> params, Option<TypeRef> returnType,
                     List<WhereClause> where) extends HasAt;
/**
 * with static parameters
 * implemented by TraitAbsDeclOrDecl, ObjectAbsDeclOrDecl, and FnAbsDeclOrDecl
 */
interface Generic(Option<List<StaticParam>> staticParams);
    /**
     * implemented by AbsTraitDecl
     */
    interface GenericAbsDeclOrDecl() extends AbsDeclOrDecl;
        /**
         * implemented by AbsObjectDecl
         */
        interface GenericAbsDeclOrDeclWithParams() extends HasParams;
        /**
         * implemented by TraitDecl
         */
        interface GenericDecl() extends Decl;
            /**
             * implemented by ObjectDecl and ObjectExpr
             */
            interface GenericDeclWithParams()
                      extends GenericAbsDeclOrDeclWithParams;
/**
 * with value parameters
 */
interface HasParams(Option<List<Param>> params,
                    List<? extends AbsDeclOrDecl> absDeclOrDecls);
/**
 * with a where clause
 */
interface HasWhere(List<WhereClause> where);

/**
 * top-level node abstract class
 */
abstract AbstractNode(ignoreForEquals Span span) extends UIDObject
                     implements HasAt, Node;
    /**
     * syntax expanders declaration in APIs
     * AbsExternalSyntax ::= syntax OpenExpander Id CloseExpander
     * OpenExpander ::= Id
     *                | LeftEncloser
     * CloseExpander ::= Id
     *                 | RightEncloser
     *                 | end
     * e.g.) syntax sql e end
     */
    AbsExternalSyntax(Name openExpander, Id id, Name closeExpander)
                     implements Decl, AbsDecl;
    /**
     * aliased dotted id used in import statements
     * AliasedDottedId ::= DottedId (as DottedId)?
     * e.g.) com.sun.fortress.parser.precedence.resolver as precedence.resolver
     */
    AliasedDottedId(DottedId dottedId, Option<DottedId> alias);
    /**
     * aliased name used in import statements
     * AliasedName ::= Id (as DottedId)?
     *               | opr Op (as Op)?
     *               | opr EncloserPair (as EncloserPair)?
     * e.g.) longComplexName as shortName
     */
    AliasedName(FnName fnName, Option<FnName> alias);
    /**
     * array comprehension clause
     * ArrayComprehensionLeft ::= IdOrInt |-> Expr
     *                          | ( IdOrInt, IdOrIntList ) |-> Expr
     * IdOrInt ::= Id
     *           | IntLiteral
     * ArrayComprehensionClause ::= ArrayComprehensionLeft | GeneratorList
     * e.g.) (x, y) = 0 | x <- {0, 1, 2}, y <- {0, 1, 2}
     */
    ArrayComprehensionClause(List<Expr> bind, Expr init, List<Generator> gens);
    /**
     * binding used in tuple expressions and typecase expressions
     * Binding ::= Id = Expr
     * e.g.) x = myLoser.myField
     */
    Binding(Id id, Expr init);
    /**
     * case clause used in case expressions and extremum expressions
     * CaseClause ::= Expr => BlockElems
     * e.g.) { Jupiter, Saturn, Uranus, Neptune } => "outer"
     */
    CaseClause(Expr match, List<Expr> body);
    /**
     * contracts used in functional declarations and object declarations
     * Contract ::= Requires? Ensures? Invariant?
     * e.g.) requires { n GE 0 } ensures { result GE 0 }
     */
    Contract(List<Expr> requires, List<EnsuresClause> ensures,
             List<Expr> invariants);
    /**
     * condition expression used in case expressions and extremum expressions
     */
    abstract CaseParam();
        /**
         * condition expression used in case expressions
         */
        CaseParamExpr(Expr expr);
        /**
         * "largest" used in extremum expressions
         */
        CaseParamLargest();
        /**
         * "smallest" used in extremum expressions
         */
        CaseParamSmallest();
    /**
     * catch clause used in try expressions
     * Catch ::= catch Id CatchClauses
     * e.g.) catch e IOException => throw ForbiddenException(e)
     */
    Catch(Id id, List<CatchClause> clauses);
    /**
     * each clause in a catch clause used in try expressions
     * CatchClause ::= TraitType => BlockElems
     * e.g.) IOException => throw ForbiddenException(e)
     */
    CatchClause(TypeRef match, List<Expr> body);
    /**
     * compilation unit
     * CompilationUnit ::= Component | Api
     */
    abstract CompilationUnit(DottedId dottedId, List<Import> imports);
        /**
         * component
         * Component ::= component DottedId Imports? Exports Decls? end
         * e.g.) component Hello
         *         export Executable
         *         run(args:String...) = print "Hello, World!\n"
         *       end
         */
        Component(List<Export> exports, List<? extends AbsDeclOrDecl> decls);
        /**
         * API
         * Api ::= api DottedId Imports? AbsDecls? end
         * e.g.) api Executable
         *         run(args:String...):()
         *       end
         */
        Api(List<? extends AbsDeclOrDecl> absDecls);
    /**
     * operators on dimensions and units
     * DUPreOp ::= square | cubic | inverse
     * DUPostOp ::= squared | cubed
     * e.g.) meter per second squared
     */
    abstract DimUnitOp();
        /**
         * e.g.) meter per second squared
         */
        SquareDimUnit();
        /**
         * e.g.) grams per cubic centimeter
         */
        CubicDimUnit();
        /**
         * e.g.) inverse ohms
         */
        InverseDimUnit();
    /**
     * dimension declaration (Not Yet Implemented in the Parser!)
     * DimUnitDecl ::= dim Id ( = DimRef )? ( default Id)?
     *               | ( unit | SI_unit ) Id+ ( : DimRef )? ( = Expr)?
     *               | dim Id ( = DimRef )? ( unit | SI_unit ) Id+ ( = Expr)?
     * e.g.) dim Length SI unit meter meters m
     */
    DimDecl(Id id, Option<TypeRef> derived, Option<TypeRef> default)
           implements Decl;
    /**
     * block expression used in do expressions
     * DoFront ::= (at Expr)? atomic? do BlockElems?
     * e.g.) at a.region(j) do w := a_j
     */
    DoFront(Option<Expr> loc, boolean atomic, Expr expr);
    /**
     * ensures clause used in contracts
     * EnsuresClause ::= Expr (provided Expr)?
     * e.g.) ensures { result GE 0 }
     */
    EnsuresClause(Expr post, Option<Expr> pre);
    /**
     * key/value pair used in map expressions
     * Entry ::= Expr |-> Expr
     * e.g.) 'a' |-> 0
     */
    Entry(Expr key, Expr value);
    /**
     * export statement
     * Exports ::= ExportExport ::= export DottedIds
     * e.g.) export Executable
     */
    Export(List<DottedId> dottedIds);
    /**
     * expression
     */
    abstract Expr(boolean is_parenthesized);
        /**
         * type ascription expression
         * Expr ::= Expr as TypeRef
         * e.g.) 3 as Number
         */
        AsExpr(Expr expr, TypeRef type);
        /**
         * type assumption expression
         * Expr ::= Expr asif TypeRef
         * e.g.) Empty asif List[\String\]
         */
        AsIfExpr(Expr expr, TypeRef type);
        /**
         * assignment expression
         * Expr ::= AssignLefts AssignOp Expr
         * AssignLefts ::= ( AssignLeft(, AssignLeft)* )
         *               | AssignLeft
         * AssignLeft ::= SubscriptExpr
         *              | FieldSelection
         *              | Id
         * e.g.) x += 1
         */
        Assignment(List<? extends LHS> lhs, Option<Op> op, Expr rhs);
        /**
         * expressions begging and ending with reserved words
         */
        abstract DelimitedExpr();
            /**
             * sequence of block elements implicitly enclosed by do/end
             * BlockElems ::= BlockElem+
             * e.g.) y = x
             *       z = 2x
             *       y + z
             */
            Block(List<Expr> exprs);
            /**
             * case expression or extremum expression
             * DelimitedExpr ::= case Expr Op? of CaseClauses CaseElse? end
             *                 | case largest Op? of CaseClauses end
             *                 | case smallest Op? of CaseClauses end
             * CaseElse ::= else => BlockElems
             * e.g.) case largest of
             *         1 mile => "miles are larger"
             *         1 kilometer => "we were wrong again"
             *       end
             */
            CaseExpr(CaseParam param, Option<Op> compare,
                     List<CaseClause> clauses,
                     Option<List<Expr>> elseClause);
            /**
             * do expression
             * Do ::= (DoFront also)* DoFront end
             * e.g.) do
             *         accum += treeSum(t.left)
             *       also do
             *         accum += treeSum(t.right)
             *       also do
             *         accum += t.datum
             *       end
             */
            Do(List<DoFront> fronts);
            /**
             * for expression
             * DelimitedExpr ::= for GeneratorList DoFront end
             * e.g.) for i <- sequential(1:5) do
             *         print (i " ")
             *       end
             */
            For(List<Generator> gens, DoFront body);
            /**
             * if expression
             * DelimitedExpr ::= if Expr then BlockElems Elifs? Else? end
             * Elif ::= elif Expr then BlockElems
             * Else ::= else BlockElems
             * e.g.) if x IN {0, 1, 2} then 0
             *       elif x IN {3, 4, 5} then 3
             *       else 6 end
             */
            If(List<IfClause> clauses, Option<Expr> elseClause);
            /**
             * label expression
             * DelimitedExpr ::= label Id BlockElems end Id
             * e.g.) label I_95
             *         if goingTo(Sun)
             *         then exit I_95 with x32B
             *         else x32A
             *         end
             *       end I_95
             */
            Label(Id id, Expr body);
            /**
             * object expression
             */
            abstract AbstractObjectExpr(Option<List<TypeRef>> extendsClause,
                                        List<? extends AbsDeclOrDecl> absDeclOrDecls);
                /**
                 * object expression
                 * DelimitedExpr ::= object Extends? GoInAnObject end
                 * e.g.)  object extends {List}
                 *          cons(x) = Cons(x, self)
                 *          append (xs) = xs
                 *        end
                 */
                ObjectExpr();
                /**
                 * object expression rewritten by interpreter.rewrite.Disambiguate
                 */
                _RewriteObjectExpr(BATree<String, StaticParam> implicitTypeParameters,
                                   String genSymName,
                                   Option<List<StaticParam>> staticParams,
                                   List<StaticArg> staticArgs,
                                   Option<List<Param>> params)
                                  implements GenericDeclWithParams;
            /**
             * try expression
             * DelimitedExpr ::= try BlockElems Catch? (forbid TraitTypes)? (finally BlockElems)? end
             * e.g.) try
             *         inp = read (file)
             *         write (inp, newFile)
             *       forbid IOException
             *       end
             */
            Try(Expr body, Option<Catch> catchClause, List<TypeRef> forbid,
                Option<Expr> finallyClause);
            /**
             * tuple expression (Mismatch with the Spec!)
             * Parenthesized ::= ( (Expr,)*  (Expr...,)? Binding(, Binding)* )
             *                 | NoKeyTuple
             * NoKeyTuple ::= ( (Expr,)* Expr... )
             *              | ( (Expr,)* Expr )
             * e.g.) (1, 2, [3 4]..., x = 5)
             */
            AbstractTupleExpr(List<Expr> exprs);
                TupleExpr();
                KeywordsExpr(List<Pair<Id, Expr>> keywords);
            /**
             * typecase expression
             * DelimitedExpr ::= typecase TypecaseBindings of TypecaseClauses
             *                     CaseElse? end
             * TypecaseBindings ::= ( BindgingList )
             *                    | Binding
             *                    | Id
             * e.g.) typecase x = myLoser .myField of
             *         String => x.append("foo")
             *         Number => x + 3
             *         Object => yogiBerraAutograph
             *       end
             */
            Typecase(List<Binding> bind, List<TypecaseClause> clauses,
                     Option<List<Expr>> elseClause);
            /**
             * varargs expression used in tuple expressions (Mismatch with the Spec!)
             * VarargsExpr ::= Expr...
             * e.g.) [3 4 5]...
             */
            VarargsExpr(Expr varargs);
            /**
             * while expression
             * DelimitedExpr ::= while Expr Do
             * e.g.) while x < 10 do print x; x += 1 end
             */
            While(Expr test, Expr body);
        /**
         * control flow expression
         */
        abstract FlowExpr();
            /**
             * summation and other reduction expression
             * FlowExpr ::= Accumulator ([ GeneratorList ])? Expr
             * e.g.) PRODUCT[i <- 1:n] i
             */
            Accumulator(Op op, List<Generator> gens, Expr body);
            /**
             * atomic expression
             * FlowExpr ::= atomic AtomicBack
             * AtomicBack ::= AssignLefts AssignOp Expr
             *              | OpExpr
             *              | DelimitedExpr
             * e.g.) atomic sum += a[i]
             */
            AtomicExpr(Expr expr);
            /**
             * exiting labeled expressions
             * FlowExpr ::= exit Id? (with Expr)?
             * e.g.) exit I_95 with x32B
             */
            Exit(Option<Id> optId, Option<Expr> returnExpr);
            /**
             * spawn expression
             * FlowExpr ::= spawn Expr
             * e.g.) spawn mm(lefttop, right, resulttop)
             */
            Spawn(Expr body);
            /**
             * throw expression
             * FlowExpr ::= throw Expr
             * e.g.) throw Error
             */
            Throw(Expr expr);
            /**
             * tryatomic expression
             * FlowExpr ::= tryatomic AtomicBack
             * e.g.) tryatomic sum += a[i]
             */
            TryAtomicExpr(Expr expr);
        /**
         * function expression
         * Expr ::= fn ValParam IsType? Throws? => Expr
         * e.g.) fn x => x + 2
         */
        FnExpr(FnName fnName, Option<List<StaticParam>> staticParams,
               List<Param> params, Option<TypeRef> returnType,
               List<WhereClause> where, List<TypeRef> throwsClause, Expr body)
              implements Decl, Applicable;
        /**
         * expression used in block expressions
         */
        abstract LetExpr(List<Expr> body) implements AbsDeclOrDecl;
            /**
             * generated expression
             * BlockElem ::= Expr(, GeneratorList)?
             * e.g.) print (i " "), i <- sequential(1:5)
             */
            GeneratedExpr(Expr expr, List<Generator> gens);
            /**
             * local function declaration
             * LocalFnDecl ::= LocalFnMods? FnHeaderFront FnHeaderClause = Expr
             * e.g.) localFn(x: ZZ32) = x + 2
             */
            LetFn(List<FnDecl> fns);
            /**
             * local variable declaration
             * LocalVarDecl ::= var? LocalVarWTypes InitVal
             *                | var? LocalVarWTypes
             *                | var? LocalVarWoTypes = Expr
             *                | var? LocalVarWoTypes : TypeRef ... InitVal?
             *                | var? LocalVarWoTypes : SimpleTupleType InitVal?
             * LocalVarWTypes ::= LocalVarWType
             *                  | ( LocalVarWType(, LocalVarWType)+ )
             * LocalVarWType ::= Id IsType
             * LocalVarWoTypes ::= LocalVarWoType
             *                   | ( LocalVarWoType(, LocalVarWoType)+ )
             * LocalVarWoType ::= Id
             *                  | Unpasting
             * e.g.) localVar x = 3
             */
            LocalVarDecl(List<LValue> lhs, Option<Expr> rhs);
        /**
         * expression that is simple or using operators
         */
        abstract OpExpr();
            /**
             * expression using operators
             * OpExpr ::= EncloserOp OpExpr? EncloserOp?
             *          | OpExpr EncloserOp OpExpr?
             *          | Primary
             * EncloserOp ::= Encloser
             *              | Op
             * e.g.) 3 + 5
             */
            OprExpr(OprName op, List<Expr> args);
            /**
             * primary expression
             */
            abstract Primary();
                /**
                 * functional application
                 * Primary ::= Primary . Id ([\StaticArgList\])? Parenthesized
                 *           | Primary . Id ([\StaticArgList\])? ()
                 *           | Primary Parenthesized
                 *           | Primary ()
                 *           | Primary Primary
                 * e.g.) myString.replace("foo", "few")
                 * e.g.) log log n
                 */
                Apply(Expr fn, Expr args);
                /**
                 * simple expression
                 */
                abstract BaseExpr();
                    /**
                     * map expression
                     * Aggregate ::= { Entry (, Entry)* }
                     * e.g.) { 'a' |-> 0, 'b' |-> 1, 'c' |-> 2 }
                     */
                    MapExpr(List<Pair<Expr, Expr>> elements);
                    /**
                     * array expression
                     * Aggregate ::= [ RectElements ]
                     * RectElements ::= Expr MultiDimCons*
                     * MultiDimCons ::= RectSeparator Expr
                     * RectSeparator ::= ;+
                     *                 | Whitespace
                     * e.g.) [1 2 3; 4 5 6; 7 8 9]
                     */
                    abstract ArrayExpr();
                        /**
                         * array with a single element
                         * e.g.) [3]
                         */
                        ArrayElement(Expr element);
                        /**
                         * array with multiple elements
                         * e.g.) [3 4 5; 6 7 8]
                         */
                        ArrayElements(int dimension, List<ArrayExpr> elements);
                    /**
                     * literal
                     */
                    abstract Literal(String text);
                        /**
                         * number literal
                         */
                        abstract NumberLiteral();
                            /**
                             * float literal
                             * e.g.) 3.5
                             */
                            FloatLiteral(ignoreForEquals String text,
                                         BigInteger intPart,
                                         BigInteger numerator, int denomBase,
                                         int denomPower);
                            /**
                             * int literal
                             * e.g.) 7
                             */
                            IntLiteral(BigInteger val);
                        /**
                         * char literal
                         * e.g.) 'c'
                         */
                        CharLiteral(int val);
                        /**
                         * string literal
                         * e.g.) "string"
                         */
                        StringLiteral();
                        /**
                         * void literal
                         * e.g.) ()
                         */
                        VoidLiteral();
                    /**
                     * variable reference
                     * BaseExpr ::= Id
                     *            | self
                     * e.g.) length
                     */
                    VarRefExpr(Id var) implements LHS;
                /**
                 * comprehension expression
                 */
                abstract Comprehension();
                    /**
                     * array comprehension
                     * Comprehension ::= [ ArrayComprehensionClause + ]
                     * e.g.) [(x, y, 1) |-> 0.0 | x <- 1:xSize, y <- 1:ySize ]
                     */
                    ArrayComprehension(List<ArrayComprehensionClause> clauses);
                    /**
                     * comprehension with generators
                     */
                    abstract GeneratedComprehension(List<Generator> gens);
                        /**
                         * set comprehension
                         * Comprehension ::= { Expr | GeneratorList }
                         * e.g.) { x^2 | x <- {0, 1, 2, 3, 4, 5}, x MOD 2 = 0 }
                         */
                        SetComprehension(Expr element);
                        /**
                         * map comprehension
                         * Comprehension ::= { Entry | GeneratorList }
                         * e.g.) { x^2 |-> x^3 | x <- {0, 1, 2, 3, 4, 5} }
                         */
                        MapComprehension(Expr key, Expr value);
                        /**
                         * list comprehension
                         * Comprehension ::= <| Expr | GeneratorList |>
                         * e.g.)
                         */
                        ListComprehension(Expr element);
                /**
                 * chain expression
                 * Certain infix mathematical operators that are traditionally
                 * regarded as relational operators, delivering boolean results,
                 * may be chained.
                 * e.g.) A SUBSETEQ B SUBSET C SUBSETEQ D
                 */
                ChainExpr(Expr first, List<Pair<Op, Expr>> links);
                /**
                 * field selection expression
                 * Primary ::= Primary . Id
                 * e.g.) Empty.length
                 */
                FieldSelection(Expr obj, Id id) implements LHS;
                /**
                 * juxtaposition with intervening whitespace
                 * e.g.) 3 5
                 */
                LooseJuxt(List<Expr> exprs);
                /**
                 * juxtaposition without intervening whitespace
                 * e.g.) f(3+5)
                 */
                TightJuxt(List<Expr> exprs);
                /**
                 * expression with static instantiations
                 * Primary ::= Id[\StaticArgList\]
                 * e.g.) identity[\String\]
                 */
                TypeApply(Expr expr, List<StaticArg> args);
            /**
             * subscripting expression
             * SubscriptExpr ::= Primary [ ExprList? ]
             *                 | Primary LeftEncloser ExprList? RightEncloser
             * e.g.) a[i]
             */
            SubscriptExpr(Expr obj, List<Expr> subs, Option<Enclosing> op)
                         implements LHS;
        /**
         * unit expression representing units
         */
        abstract UnitExpr();
            /**
             * unit quantity
             * UnitRef ::= StaticArg
             * e.g.) grams per cubic centimeter
             */
            UnitRef(StaticArg val);
    /**
     * array and matrix size
     * ExtentRange ::= StaticArg? # StaticArg?
     *               | StaticArg? : StaticArg?
     *               | StaticArg
     * e.g.) 3#5
     */
    ExtentRange(Option<TypeRef> base, Option<TypeRef> size);
    /**
     * syntax expanders declaration in APIs
     * ExternalSyntax ::= syntax OpenExpander Id CloseExpander = Expr
     * e.g.) syntax sql e end = parseSQL(e)
     */
    ExternalSyntax(Name openExpander, Id id, Name closeExpander, Expr expr)
                  implements Decl, AbsDecl;
    /**
     * functional declaration in components and APIs
     */
    abstract FnAbsDeclOrDecl(List<Modifier> mods, FnName fnName,
                             Option<List<StaticParam>> staticParams,
                             List<Param> params, Option<TypeRef> returnType,
                             List<TypeRef> throwsClause, List<WhereClause> where,
                             Contract contract)
                            implements Generic, Applicable, AbsDeclOrDecl;
        /**
         * functional declaration in APIs
         * AbsFnDecl ::= AbsFnMods? FnHeaderFront FnHeaderClause
         *             | FnSig
         * FnSig ::= Name : ArrowType
         * FnHeaderFront ::= Id StaticParams? ValParam
         *                 | OpHeaderFront
         * OpHeaderFront ::= opr StaticParams? (LeftEncloser | Encloser) Params
         *                     (RightEncloser | Encloser)
         *                     (:= ( SubscriptAssignParam ))?
         *                 | opr StaticParams? ValParam Op
         *                 | opr (Op | ExponentOp | Encloser) StaticParams? ValParam
         * SubscriptAssignParam ::= Varargs | Param
         * e.g.) swap (x: Object, y: Object): (Object, Object)
         */
        AbsFnDecl(String selfName) implements Decl, AbsDecl, Applicable;
        /**
         * functional declaration in components
         * FnDecl ::= FnMods? FnHeaderFront FnHeaderClause (= Expr)?
         *          | FnSig
         * e.g.) swap (x, y) = (y, x)
         */
        FnDecl(String selfName, Expr body) implements Decl, Applicable;
    /**
     * name representing functionals
     * Note well; because this is a useful abstraction for the generalized names
     * seen in Fortress, it will persist into more semantically aware parts of
     * the system (i.e., into the interpreter, compiler, typechecker, etc).
     */
    abstract FnName();
        /**
         * qualified name
         * DottedId ::= Id(.Id)*
         * e.g.) com.sun.fortress.nodes_util.getName
         */
        DottedId(List<String> names);
        /**
         * functional name
         * e.g.) isEmpty
         */
        Fun(Id name);
        /**
         * identifier or operator name
         * Name ::= Id
         *        | opr Op
         * e.g.) opr +
         */
        Name(Option<Id> id, Option<Op> op);
        /**
         * operator name
         */
        abstract OprName();
            /**
             * pair of enclosing operators
             * EncloserPair ::= LeftEncloser RightEncloser
             * e.g.) </ />
             */
            Enclosing(Op open, Op close);
            /**
             * operator
             * e.g.) COMPOSE
             * e.g.) +
             */
            Opr(Op op);
            /**
             * postfix operator
             * e.g.) 3!
             */
            PostFix(Op op);
            /**
             * subscripted assignment [ ] :=
             * e.g.) a[i] := 1
             */
            SubscriptAssign();
            /**
             * subscripting operator [ ]
             * e.g.) a[i]
             */
            SubscriptOp();
            /**
             * name for anonymous functionals
             * not created during parsing but during evaluation
             * e.g.) name for "fn x => x + 1"
             */
            AnonymousFnName();
            /**
             * name for anonymous constructors
             * not created during parsing but during evaluation
             * e.g.) name for "object extends List cons(x) = Cons(x, self) end"
             */
            ConstructorFnName(AbsDeclOrDecl def);
    /**
     * generator
     * Generator ::= IdOrIdTuple <- Expr
     *             | Expr
     * IdOrIdTuple ::= Id
     *               | ( Id, IdList )
     * e.g.) (i, j) <- my2DArray.indices
     */
    Generator(List<Id> bind, Expr init);
    /**
     * identifier
     * e.g.) hashCode
     */
    Id(String name);
    /**
     * if clause used in if expressions
     * e.g.) if x IN { 0, 1, 2 } then 0
     */
    IfClause(Expr test, Expr body);
    /**
     * import statement
     * Import ::= import ImportFrom | import AliasedDottedIds
     */
    abstract Import();
        /**
         * ImportFrom ::= * (except Names)? from DottedId
         *              | AliasedNames from DottedId
         */
        abstract ImportFrom(DottedId source);
            /**
             * e.g.) import * from Set
             */
            ImportStar(List<Name> except);
            /**
             * e.g.) import {empty, union} from Set
             */
            ImportNames(List<AliasedName> aliasedNames);
        /**
         * e.g.) import {Set, Map, List}
         */
        ImportApi(List<AliasedDottedId> apis);
    /**
     * array indices (Mismatch with the Spec!)
     */
    abstract Indices();
        /**
         * array dimensionality (Mismatch with the Spec!)
         * ArraySize ::= ExtentRange(, ExtentRange)*
         * e.g.) 3, 2#1, 3:5
         */
        FixedDim(List<ExtentRange> extents);
    /**
     * keyword type used in tuple types (Mismatch with the Spec!)
     * KeywordType ::= Id = TypeRef
     * e.g.) x = String
     */
    KeywordType(Id id, TypeRef type);
    /**
     * left-hand side of variable declaration
     */
    abstract LValue();
        /**
         * e.g.) var x: ZZ32
         */
        LValueBind(Id id, Option<TypeRef> type, List<Modifier> mods,
                   boolean mutable) implements LHS;
        /**
         * left-hand side of matrix unpasting
         * Unpasting ::= [ UnpastingElems ]
         */
        abstract Unpasting();
            /**
             * simple unpasting
             * UnpastingElem ::= Id ([ UnpastingDim ])?
             *                 | Unpasting
             * UnpastingDim ::= ExtentRange (BY ExtentRange)+
             * e.g.) squareShape[m BY m]
             */
            UnpastingBind(Id id, Option<List<ExtentRange>> dim);
            /**
             * complex unpasting
             * UnpastingElems ::= UnpastingElem RectSeparator UnpastingElems
             *                  | UnpastingElem
             * e.g.) squareShape[m BY m]  rest
             */
            UnpastingSplit(List<Unpasting> elems, int dim);
    /**
     * modifier
     */
    abstract Modifier();
        /**
         * e.g.) abstract m(x: ZZ32): ()
         */
        ModifierAbstract();
        /**
         * e.g.) atomic f(x: ZZ32): ()
         */
        ModifierAtomic();
        /**
         * e.g.) getter velocity(): (RR Velocity)^3
         */
        ModifierGetter();
        /**
         * e.g.) hidden x: ZZ32
         */
        ModifierHidden();
        /**
         * e.g.) io print(s: String): ()
         */
        ModifierIO();
        /**
         * e.g.) override m(x: ZZ32): ()
         */
        ModifierOverride();
        /**
         * e.g.) private f(): ()
         */
        ModifierPrivate();
        /**
         * e.g.) settable message: Maybe[\String\]
         */
        ModifierSettable();
        /**
         * e.g.) setter velocity(v: (RR Velocity)^3): ()
         */
        ModifierSetter();
        /**
         * e.g.) test object TestSuite(testFunctions = {}) end
         */
        ModifierTest();
        /**
         * e.g.) object O(transient x: ZZ32) end
         */
        ModifierTransient();
        /**
         * e.g.) value object IntEmpty extends List[\ZZ32\] end
         */
        ModifierValue();
        /**
         * e.g.) var x: ZZ32
         */
        ModifierVar();
        /**
         * e.g.) coerce (x: RR32) widens = ...
         */
        ModifierWidens();
        /**
         * e.g.) wrapped val: Dictionary[\T\]
         */
        ModifierWrapped();
    /**
     * object declaration in components or APIs
     */
    abstract ObjectAbsDeclOrDecl(List<Modifier> mods, Id id,
                                 Option<List<StaticParam>> staticParams,
                                 Option<List<Param>> params,
                                 Option<List<TypeRef>> extendsClause,
                                 List<TypeRef> throwsClause,
                                 List<WhereClause> where,
                                 Contract contract)
                                implements Generic, AbsDeclOrDecl;
        /**
         * object declaration in APIs
         * AbsObjectDecl ::= AbsObjectMods? ObjectHeader AbsGoInAnObject? end
         * ObjectHeader ::= object Id StaticParams? ObjectValParam? Extends?
         *                  FnClauses
         * e.g.) object Empty[\alph\]() extends List[\alpha\] end
         */
        AbsObjectDecl(List<? extends AbsDeclOrDecl> absDeclOrDecls)
                     implements GenericAbsDeclOrDeclWithParams, AbsDecl;
        /**
         * object declaration in components
         * ObjectDecl ::= ObjectMods? ObjectHeader GoInAnObject? end
         * e.g.) object Empty[\alph\]() extends List[\alpha\]
         *         length() = 0
         *       end
         */
        ObjectDecl(List<? extends AbsDeclOrDecl> absDeclOrDecls)
                  implements GenericDeclWithParams;
    /**
     * operator symbol
     * e.g.) ===
     */
    Op(String name);
    /**
     * value parameter of functional declarations and object declarations
     * e.g.) x: ZZ32 = 3
     * e.g.) self
     * e.g.) transient x: String
     */
    Param(List<Modifier> mods, Id id, Option<TypeRef> type,
          Option<Expr> defaultExpr);
    /**
     * property declaration
     * PropertyDecl ::= property (Id = )? (FORALL ValParam)? Expr
     * e.g.) property fIsMonotonic = FORALL (x: ZZ, y: ZZ) (x < y) -> (f(x) < f(y))
     */
    PropertyDecl(Option<Id> id, List<Param> params, Expr expr)
                implements Decl, AbsDecl;
    /**
     * static parameter
     */
    abstract StaticParam();
       /**
         * bool parameter
         * StaticParam ::= bool Id
         * e.g.) bool nan
         */
        BoolParam(Id id);
       /**
         * dimension parameter
         * StaticParam ::= dim Id
         * e.g.) dim D
         */
        DimensionParam(Id id);
       /**
         * int parameter
         * StaticParam ::= int Id
         * e.g.) int i
         */
        IntParam(Id id);
       /**
         * nat parameter
         * StaticParam ::= nat Id
         * e.g.) nat len
         */
        NatParam(Id id);
       /**
         * operator parameter
         * StaticParam ::= opr Op
         * e.g.) opr ODOT
         */
        OperatorParam(Op op);
       /**
         * type parameter
         * StaticParam ::= Id Extends? ( absorbs unit )?
         * e.g.) EltType extends Number absorbs unit
         */
        SimpleTypeParam(Id id, Option<List<TypeRef>> extendsClause,
                        boolean absorbs);
       /**
         * unit parameter
         * StaticParam ::= unit Id ( : DimRef )? ( absorbs unit )?
         * e.g.) unit U absrbs unit
         */
        UnitParam(Id id, Option<DimRef> dim, boolean absorbs);
    /**
     * test declaration
     * TestDecl ::= test Id [GeneratorList] = Expr
     * e.g.) test fxLessThanFy[x <- E, y <- F] = assert(f(x) < f(y))
     */
    TestDecl(Id id, List<Generator> gens, Expr expr) implements Decl, AbsDecl;
    /**
     * trait declaration in components or APIs
     */
    abstract TraitAbsDeclOrDecl(List<Modifier> mods, Id id,
                                Option<List<StaticParam>> staticParams,
                                Option<List<TypeRef>> extendsClause,
                                List<TypeRef> excludes,
                                Option<List<TypeRef>> comprises,
                                List<WhereClause> where,
                                List<? extends AbsDeclOrDecl> absDeclOrDecls)
                               implements Generic, HasWhere;
        /**
         * trait declaration in APIs
         * AbsTraitDecl ::= AbsTraitMods? TraitHeaderFront AbsTraitClauses
         *                  AbsGoInATrait? end
         * AbsTraitClause ::= Excludes | AbsComprises | Where
         * e.g.) trait List[\alpha\] comprises { Cons[\alpha\], Empty[\alpha\] }
         *         cons(x: alph): List[\alpha\]
         *       end
         */
        AbsTraitDecl() implements GenericAbsDeclOrDecl, AbsDecl;
        /**
         * trait declaration in components
         * TraitDecl ::= TraitMods? TraitHeaderFront TraitClauses GoInATrait? end
         * TraitHeaderFront ::= trait Id StaticParams? Extends?
         * TraitClause ::= Excludes | Comprises | Where
         * e.g.) trait List[\alpha\] comprises { Cons[\alpha\], Empty[\alpha\] }
         *         cons(x: alph): List[\alpha\] = Cons[\alph\](x, self)
         *       end
         */
        TraitDecl() implements GenericDecl;
    /**
     * typecase clause used in typecase expressions
     * TypecaseClause ::= TypecaseTypeRefs => BlockElems
     * TypecaseTypeRefs ::= ( TypeRefList )
     *                    | TypeRef
     * e.g.) String => x.append("foo")
     */
    TypecaseClause(List<TypeRef> match, List<Expr> body);
    /**
     * type
     * TypeRef ::= ArrowType
     *           | NonArrowType
     */
    abstract TypeRef();
        /**
         * arrow type (Mismatch with the Spec!)
         * ArrowType ::= NonArrowType -> NonArrowType Throws?
         * e.g.) (String, NN..., p = Printer) -> NN throws IOException
         */
        ArrowType(List<TypeRef> domain, TypeRef range,
                  List<TypeRef> throwsClause);
        /**
         * nonarrow type
         */
        abstract NonArrowType();
            /**
             * trait type
             */
            abstract TraitType();
                /**
                 * array type
                 * TraitType ::= TypeRef [ ArraySize? ]
                 * e.g.) ZZ64[3, 2]
                 */
                ArrayType(TypeRef element, Indices indices);
                /**
                 * matrix type
                 * TraitType ::= TypeRef ^ StaticArg
                 *             | TypeRef ^ ( ExtentRange (BY ExtentRange)* )
                 * e.g.)
                 */
                MatrixType(TypeRef element, List<ExtentRange> dimensions);
                /**
                 * instantiated type
                 * TraitType ::= DottedId ([\StaticArgList\])?
                 * e.g.) List[\ZZ32\]
                 */
                ParamType(TypeRef generic, List<StaticArg> args);
            /**
             * type name
             * e.g.) T
             */
            IdType(DottedId dottedId);
            /**
             * tuple type (Mismatch with the Spec!)
             * TupleType ::= ( (TypeRef, )* (TypeRef ... ,)? KeywordType(, KeywordType)* )
             *             | ( (TypeRef, )*  TypeRef ... )
             *             | SimpleTupleType
             * e.g.)
             */
            TupleType(List<TypeRef> elements, List<KeywordType> keywords);
            /**
             * varargs type used in tuple types (Mismatch with the Spec!)
             * TypeRef ...
             * e.g.) ZZ32...
             */
            VarargsType(TypeRef type);
            /**
             * void type
             * e.g.) ()
             */
            VoidType();
            /**
             * dimension type
             */
            abstract DimType();
                /**
                 * dimension quantity
                 * DimRef ::= StaticArg
                 * e.g.) 3
                 */
                DimRef(StaticArg val);
                /**
                 * dimension multiplication
                 * DimType ::= TypeRef DimRef
                 * e.g.) Velocity Time
                 */
                ProductDimType(TypeRef multiplier, DimRef multiplicand);
                /**
                 * dimension division
                 * DimType ::= TypeRef / DimRef
                 *           | TypeRef per DimRef
                 * e.g.) Velocity / Time
                 */
                QuotientDimType(TypeRef numerator, DimRef denominator);
                /**
                 * unit multiplication
                 * DimType ::= TypeRef UnitRef
                 * e.g.) m v^2
                 */
                ProductUnitType(TypeRef multiplier, UnitRef multiplicand);
                /**
                 * unit division
                 * DimType ::= TypeRef / UnitRef
                 *           | TypeRef per UnitRef
                 * e.g.) meters/seconds
                 */
                QuotientUnitType(TypeRef numerator, UnitRef denominator);
                /**
                 * dimension type conversion
                 * DimType ::= TypeRef in DimRef
                 * e.g.) f/s in m/s
                 */
                DimTypeConversion(TypeRef type, DimRef dim);
        /**
         * static argument
         * NOTE: StaticArg extends TypeRef because there seems to be an
         * ambiguity here, since syntactically there is not a good way to tell
         * the products of typeargs for DimType and natargs for StaticArg
         */
        abstract StaticArg();
            /**
             * number used as static argument
             * StaticArg ::= Number
             * Number ::= IntLiteral
             * e.g.) 5
             */
            BaseNatRef(int value);
            /**
             * operator used as static argument
             * StaticArg ::= Op
             * e.g.) +
             */
            BaseOprRef(FnName fnName);
            /**
             * dimension representing dimensionless
             * StaticArg ::= Unity
             * e.g.) Unity
             */
            BaseDimRef();
            /**
             * dimensionless unit
             * StaticArg ::= dimensionless
             * e.g.) dimensionless
             */
            BaseUnitRef();
            /**
             * boolean used as static argument
             */
            abstract BoolRef();
                /**
                 * boolean constant
                 * StaticArg ::= true | false
                 * e.g.) true
                 */
                BaseBoolRef(boolean bool);
                /**
                 * boolean negation
                 * StaticArg ::= NOT StaticArg
                 * e.g.) NOT ninf
                 */
                NotBoolRef(StaticArg val);
                /**
                 * boolean disjunction
                 * StaticArg ::= StaticArg OR StaticArg
                 * e.g.) ninf OR pinf
                 */
                OrBoolRef(StaticArg left, StaticArg right);
                /**
                 * boolean conjunction
                 * StaticArg ::= StaticArg AND StaticArg
                 * e.g.) ninf AND pinf
                 */
                AndBoolRef(StaticArg left, StaticArg right);
                /**
                 * boolean implication
                 * StaticArg ::= StaticArg IMPLIES StaticArg
                 * e.g.) gt AND eq IMPLIES ge
                 */
                ImpliesBoolRef(StaticArg left, StaticArg right);
            /**
             * static argument with operation
             */
            abstract CompoundStaticArg();
                /**
                 * summation of static arguments
                 * StaticArg ::= StaticArg + StaticArg
                 * e.g.) len + 2
                 */
                SumStaticArg(List<StaticArg> values);
                /**
                 * multiplication of static arguments
                 * StaticArg ::= StaticArg StaticArg
                 * e.g.) a + m c < n
                 */
                ProductStaticArg(List<StaticArg> values);
                /**
                 * division of static arguments
                 * StaticArg ::= StaticArg / StaticArg
                 *             | 1 / StaticArg
                 *             | StaticArg per StaticArg
                 * e.g.) kilograms per cubic meter
                 */
                QuotientStaticArg(TypeRef numerator, TypeRef denominator);
                /**
                 * exponentiation of static arguments
                 * StaticArg ::= StaticArg ^ StaticArg
                 * e.g.) Length ^ 3
                 */
                ExponentStaticArg(TypeRef base, TypeRef power);
                /**
                 * static argument with dimension operation
                 * StaticArg ::= DUPreOp StaticArg
                 *             | StaticArg DUPostOp
                 * e.g.) meters per second squared
                 */
                DimensionStaticArg(StaticArg val, DimUnitOp op);
            /**
             * type as static argument
             * StaticArg ::= TypeRef
             * e.g.) List[\ZZ64\]
             */
            TypeArg(TypeRef type);
    /**
     * unit declaration
     * DimUnitDecl ::= dim Id ( = DimRef )? ( default Id)?
     *               | ( unit | SI_unit ) Id+ ( : DimRef )? ( = Expr)?
     *               | dim Id ( = DimRef )? ( unit | SI_unit ) Id+ ( = Expr)?
     * e.g.) unit inch inches: Length
     */
    UnitDecl(List<Id> names, Option<TypeRef> type, Option<Expr> def, boolean si)
            implements Decl;
    /**
     * variable declaration in components or APIs
     */
    abstract VarAbsDeclOrDecl(List<LValue> lhs) implements AbsDeclOrDecl;
        /**
         * variable declaration in APIs
         * AbsVarDecl ::= AbsVarMods? VarWTypes
         *              | AbsVarMods? IdOrIdTuple : TypeRef ...
         *              | AbsVarMods? IdOrIdTuple : SimpleTupleType
         * AbsVarMods ::= AbsVarMod+
         * AbsVarMod ::= var | test
         * e.g.) var (x, y): ZZ64...
         */
        AbsVarDecl() implements AbsDecl;
        /**
         * variable declaration in components
         * VarDecl ::= VarMods? VarWTypes InitVal
         *           | VarMods? IdOrIdTuple = Expr
         *           | VarMods? IdOrIdTuple : TypeRef ... InitVal
         *           | VarMods? IdOrIdTuple : SimpleTupleType InitVal
         * VarMods ::= VarMod+
         * VarMod ::= AbsVarMod | private
         * VarWTypes ::= VarWType | ( VarWType(, VarWType)+ )
         * VarWType ::= Id IsType
         * e.g.) var (x, y): ZZ64... = (5, 6)
         */
        VarDecl(Expr init) implements Decl;
    /**
     * where clause used in trait, object, and functional declarations
     * Where ::= where { WhereClauseList }
     * e.g.) where { ninf AND NOT nan }
     */
    abstract WhereClause();
        /**
         * type alias declaration
         * TypeAlias ::= type Id StaticParams? = TypeRef
         * e.g.) type IntList = List[\ZZ64\]
         */
        TypeAlias(Id id, List<StaticParam> staticParams, TypeRef type)
                 implements Decl;
        /* bool parameter declared in where clauses (Mismatch with the Spec!)
         * WhereClause ::= bool Id
         * e.g.) bool ninf
         */
        WhereBool(Id id);
        /* hidden type variable declared in where clauses
         * WhereClause ::= Id Extends
         * e.g.) T extends Object
         */
        WhereExtends(Id id, List<TypeRef> supers);
        /* nat parameter declared in where clauses (Mismatch with the Spec!)
         * WhereClause ::= nat Id
         * e.g.) nat length
         */
        WhereNat(Id id);
        /* unit parameter declared in where clauses (Mismatch with the Spec!)
         * WhereClause ::= unit Id
         * e.g.) unit U
         */
        WhereUnit(Id id);
        /* coercion constraint declared in where clauses
         * WhereClause ::= TypeRef coerces TypeRef
         * e.g.) T coerces Identity[\ODOT\]
         */
        WhereCoerces(TypeRef first, TypeRef second);
        /* widening constraint declared in where clauses
         * WhereClause ::= TypeRef widens TypeRef
         * e.g.) T widens S
         */
        WhereWidens(TypeRef first, TypeRef second);
        /* widening coercion constraint declared in where clauses
         * WhereClause ::= TypeRef widens or coerces TypeRef
         * e.g.) T widens or coerces S
         */
        WhereWidensCoerces(TypeRef first, TypeRef second);
        /* compound constraint declared in where clauses
         * WhereClause ::= StaticArg
         * e.g.) where {lt AND eq AND gt, U = dimensionless}
         */
        WhereConstraint(StaticArg constraint);
end;
