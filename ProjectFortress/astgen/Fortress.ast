/*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

generateEmptyConstructor yes;   // for reflective object creation
visitMethod accept;
visitorMethodPrefix for;
addGetterPrefixes yes;
usePLT yes;
tabSize 4;
allowNulls no;
generateToString yes;
generateEquals yes;
generateSerializers yes;

package com.sun.fortress.nodes;
import java.io.IOException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import com.sun.fortress.nodes_util.*;
import com.sun.fortress.useful.*;

begin ast;

/**
 * top-level node interface
 */
interface Node();
    /**
     * declaration in components or APIs
     */
    interface AbsDeclOrDecl() extends HasAt;
        /**
         * declaration in APIs
         */
        interface AbsDecl();
        /**
         * declaration in components
         */
        interface Decl();
    /**
     * left-hand-sides of assignments, local variable declarations, and
     * top-level declarations.
     */
    interface LHS();
/**
 * functional declaration or function expression
 */
interface Applicable(FnName fnName, Option<List<StaticParam>> staticParams,
                     List<Param> params, Option<TypeRef> returnType,
                     List<WhereClause> where) extends HasAt;
/**
 * with static parameters
 * implemented by TraitAbsDeclOrDecl, ObjectAbsDeclOrDecl, and FnAbsDeclOrDecl
 */
interface Generic(Option<List<StaticParam>> staticParams);
    /**
     * implemented by AbsTraitDecl
     */
    interface GenericAbsDeclOrDecl() extends AbsDeclOrDecl;
        /**
         * implemented by AbsObjectDecl
         */
        interface GenericAbsDeclOrDeclWithParams() extends HasParams;
        /**
         * implemented by TraitDecl
         */
        interface GenericDecl() extends Decl;
            /**
             * implemented by ObjectDecl and ObjectExpr
             */
            interface GenericDeclWithParams()
                      extends GenericAbsDeclOrDeclWithParams;
/**
 * with value parameters
 */
interface HasParams(Option<List<Param>> params,
                    List<? extends AbsDeclOrDecl> absDeclOrDecls);
/**
 * with a where clause
 */
interface HasWhere(List<WhereClause> where);

/**
 * top-level node abstract class
 */
abstract AbstractNode(ignoreForEquals Span span) extends UIDObject
                     implements HasAt, Node;
    /**
     * syntax expanders declaration in APIs
     * AbsExternalSyntax ::= syntax OpenExpander Id CloseExpander
     * e.g.) syntax sql e end
     */
    AbsExternalSyntax(Name openExpander, Id id, Name closeExpander)
                     implements Decl, AbsDecl;
    /**
     * aliased dotted id used in import statements
     * AliasedDottedId ::= DottedId (as DottedId)?
     * e.g.) com.sun.fortress.parser.precedence.resolver as precedence.resolver
     */
    AliasedDottedId(DottedId dottedId, Option<DottedId> alias);
    /**
     * aliased dotted name used in import statements
     * AliasedName ::= Id (as DottedId)?
     *               | opr Op (as Op)?
     *               | opr EncloserPair (as EncloserPair)?
     * e.g.) longComplexName as shortName
     */
    AliasedName(FnName fnName, Option<FnName> alias);
    /**
     * array comprehension clause
     * ArrayComprehensionClause ::= ArrayComprehensionLeft | GeneratorList
     * e.g.) [(x, y) = 0 | x <- {0, 1, 2}, y <- {0, 1, 2}]
     */
    ArrayComprehensionClause(List<Expr> bind, Expr init, List<Generator> gens);
    /**
     * binding used in tuple expressions and typecase expressions
     * Binding ::= Id = Expr
     * e.g.) x = myLoser.myField
     */
    Binding(Id id, Expr init);
    /**
     * case clause used in case expressions and extremum expressions
     * CaseClause ::= Expr => BlockElems
     * e.g.) { Jupiter, Saturn, Uranus, Neptune } => "outer"
     */
    CaseClause(Expr match, List<Expr> body);
    /**
     * contracts used in functional declarations and object declarations
     * Contract ::= Requires? Ensures? Invariant?
     * e.g.) requires { n GE 0 } ensures { result GE 0 }
     */
    Contract(List<Expr> requires, List<EnsuresClause> ensures,
             List<Expr> invariants);
    /**
     * condition expression used in case expressions and extremum expressions
     */
    abstract CaseParam();
        /**
         * condition expression used in case expressions
         */
        CaseParamExpr(Expr expr);
        /**
         * "largest" used in extremum expressions
         */
        CaseParamLargest();
        /**
         * "smallest" used in extremum expressions
         */
        CaseParamSmallest();
    /**
     * catch clause used in try expressions
     * Catch ::= catch Id CatchClauses
     * e.g.) catch e IOException => throw ForbiddenException(e)
     */
    Catch(Id id, List<CatchClause> clauses);
    /**
     * each clause in a catch clause used in try expressions
     * CatchClause ::= TraitType => BlockElems
     * e.g.) IOException => throw ForbiddenException(e)
     */
    CatchClause(TypeRef match, List<Expr> body);
    /**
     * compilation unit
     * CompilationUnit ::= Component | Api
     */
    abstract CompilationUnit(DottedId dottedId, List<Import> imports);
        /**
         * component
         * Component ::= component DottedId Imports? Exports Decls? end
         * e.g.) component Hello
         *         export Executable
         *         run(args:String...) = print "Hello, World!\n"
         *       end
         */
        Component(List<Export> exports, List<? extends AbsDeclOrDecl> decls);
        /**
         * API
         * Api ::= api DottedId Imports? AbsDecls? end
         * e.g.) api Executable
         *         run(args:String...):()
         *       end
         */
        Api(List<? extends AbsDeclOrDecl> absDecls);
    /**
     * operators on dimensions and units
     * DUPreOp ::= square | cubic | inverse
     * DUPostOp ::= squared | cubed
     * e.g.) meter per second squared
     */
    abstract DimUnitOp();
        /**
         * e.g.) meter per second squared
         */
        SquareDimUnit();
        /**
         * e.g.) grams per cubic centimeter
         */
        CubicDimUnit();
        /**
         * e.g.) inverse ohms
         */
        InverseDimUnit();
    /**
     * dimension declaration (Not Yet Implemented in the Parser!)
     * DimUnitDecl ::= dim Id ( = DimRef )? ( default Id)?
     *               | ( unit | SI_unit ) Id+ ( : DimRef )? ( = Expr)?
     *               | dim Id ( = DimRef )? ( unit | SI_unit ) Id+ ( = Expr)?
     * e.g.) SI_unit gram grams g: Mass
     */
    DimDecl(Id id, Option<TypeRef> derived, Option<TypeRef> default)
           implements Decl;
    /**
     * block expression used in do expressions
     * DoFront ::= (at Expr)? atomic? do BlockElems?
     * e.g.) at a.region(j) do w := a_j
     */
    DoFront(Option<Expr> loc, boolean atomic, Expr expr);
    /**
     * ensures clause used in contracts
     * EnsuresClause ::= Expr (provided Expr)?
     * e.g.) ensures { result GE 0 }
     */
    EnsuresClause(Expr post, Option<Expr> pre);
    /**
     * key/value pair used in map expressions
     * Entry ::= Expr |-> Expr
     * e.g.) 'a' |-> 0
     */
    Entry(Expr key, Expr value);
    /**
     * export statement
     * Exports ::= ExportExport ::= export DottedIds
     * e.g.) export Executable
     */
    Export(List<DottedId> dottedIds);
    /**
     * expression
     */
    abstract Expr(boolean is_parenthesized);
        /**
         * type ascription expression
         * Expr ::= Expr as TypeRef
         * e.g.) 3 as Number
         */
        AsExpr(Expr expr, TypeRef type);
        /**
         * type assumption expression
         * Expr ::= Expr asif TypeRef
         * e.g.) Empty asif List[\String\]
         */
        AsIfExpr(Expr expr, TypeRef type);
        /**
         * assignment expression
         * Expr ::= AssignLefts AssignOp Expr
         * AssignLefts ::= ( AssignLeft(, AssignLeft)* )
         *               | AssignLeft
         * AssignLeft ::= SubscriptExpr
         *              | FieldSelection
         *              | Id
         * e.g.) x += 1
         */
        Assignment(List<? extends LHS> lhs, Option<Op> op, Expr rhs);
        /**
         * expressions begging and ending with reserved words
         */
        abstract DelimitedExpr();
            /**
             * sequence of block elements implicitly enclosed by do/end
             * BlockElems ::= BlockElem+
             * e.g.) y = x
             *       z = 2x
             *       y + z
             */
            Block(List<Expr> exprs);
            /**
             * case expression or extremum expression
             * DelimitedExpr ::= case Expr Op? of CaseClauses CaseElse? end
             *                 | case largest Op? of CaseClauses end
             *                 | case smallest Op? of CaseClauses end
             * e.g.) case largest of
             *         1 mile => "miles are larger"
             *         1 kilometer => "we were wrong again"
             *       end
             */
            CaseExpr(CaseParam param, Option<Op> compare,
                     List<CaseClause> clauses,
                     Option<List<Expr>> elseClause);
            /**
             * do expression
             * Do ::= (DoFront also)* DoFront end
             * e.g.) do
             *         accum += treeSum(t.left)
             *       also do
             *         accum += treeSum(t.right)
             *       also do
             *         accum += t.datum
             *       end
             */
            Do(List<DoFront> fronts);
            /**
             * for expression
             * DelimitedExpr ::= for GeneratorList DoFront end
             * e.g.) for i <- sequential(1:5) do
             *         print (i " ")
             *       end
             */
            For(List<Generator> gens, DoFront body);
            /**
             * if expression
             * DelimitedExpr ::= if Expr then BlockElems Elifs? Else? end
             * e.g.) if x IN {0, 1, 2} then 0
             *       elif x IN {3, 4, 5} then 3
             *       else 6 end
             */
            If(List<IfClause> clauses, Option<Expr> elseClause);
            /**
             * label expression
             * DelimitedExpr ::= label Id BlockElems end Id
             * e.g.) label I_95
             *         if goingTo(Sun)
             *         then exit I_95 with x32B
             *         else x32A
             *         end
             *       end I_95
             */
            Label(Id id, Expr body);
            /**
             * object expression
             */
            abstract AbstractObjectExpr(Option<List<TypeRef>> extendsClause,
                                        List<? extends AbsDeclOrDecl> absDeclOrDecls);
                /**
                 * object expression
                 * DelimitedExpr ::= object Extends? GoInAnObject end
                 * e.g.)  object extends {List}
                 *          cons(x) = Cons(x, self)
                 *          append (xs) = xs
                 *        end
                 */
                ObjectExpr();
                /**
                 * object expression rewritten by interpreter.rewrite.Disambiguate
                 */
                _RewriteObjectExpr(BATree<String, StaticParam> implicitTypeParameters,
                                   String genSymName,
                                   Option<List<StaticParam>> staticParams,
                                   List<StaticArg> staticArgs,
                                   Option<List<Param>> params)
                                  implements GenericDeclWithParams;
            /**
             * try expression
             * DelimitedExpr ::= try BlockElems Catch? (forbid TraitTypes)? (finally BlockElems)? end
             * e.g.) try
             *         inp = read (file)
             *         write (inp, newFile)
             *       forbid IOException
             *       end
             */
            Try(Expr body, Option<Catch> catchClause, List<TypeRef> forbid,
                Option<Expr> finallyClause);
            /**
             * tuple expression (Mismatch with the Spec!)
             * Parenthesized ::= ( (Expr,)*  (Expr...,)? Binding(, Binding)* )
             *                 | NoKeyTuple
             * NoKeyTuple ::= ( (Expr,)* Expr... )
             *              | ( (Expr,)* Expr )
             * e.g.) (1, 2, [3 4]..., x = 5)
             */
            AbstractTupleExpr(List<Expr> exprs);
                TupleExpr();
                KeywordsExpr(List<Pair<Id, Expr>> keywords);
            /**
             *
             *
             * e.g.)
             */
            TypeCase(List<Binding> bind, List<TypeCaseClause> clauses,
                             Option<List<Expr>> elseClause);
            /**
             *
             *
             * e.g.)
             */
            VarargsExpr(Expr varargs);
            /**
             *
             *
             * e.g.)
             */
            While(Expr test, Expr body);
        /**
         *
         *
         * e.g.)
         */
        abstract FlowExpr();
            Accumulator(Op op, List<Generator> gens, Expr body);
            AtomicExpr(Expr expr);
            Exit(Option<Id> name, Option<Expr> returnExpr);
            Spawn(Expr body);
            Throw(Expr expr);
            TryAtomicExpr(Expr expr);
        /**
         *
         *
         * e.g.)
         */
        FnExpr(FnName fnName, Option<List<StaticParam>> staticParams,
                     List<Param> params, Option<TypeRef> returnType,
                     List<WhereClause> where, List<TypeRef> throwsClause, Expr body)
                     implements Decl, Applicable;
        /**
         *
         *
         * e.g.)
         */
        abstract LetExpr(List<Expr> body) implements AbsDeclOrDecl;
            GeneratedExpr(Expr expr, List<Generator> gens);
            LetFn(List<FnDecl> fns);
            LocalVarDecl(List<LValue> lhs, Option<Expr> rhs);
        /**
         *
         *
         * e.g.)
         */
        abstract OpExpr();
            OprExpr(OprName op, List<Expr> args);
            abstract Primary();
                Apply(Expr fn, Expr args);
                abstract BaseExpr();
                    MapExpr(List<Pair<Expr, Expr>> elements);
                    abstract ArrayExpr();
                        ArrayElement(Expr element);
                        ArrayElements(int dimension, List<ArrayExpr> elements);
                    abstract Literal(String text);
                        abstract NumberLiteral();
                            FloatLiteral(ignoreForEquals String text, BigInteger intPart,
                                                     BigInteger numerator, int denomBase, int denomPower);
                            IntLiteral(BigInteger val);
                        CharLiteral(int val);
                        StringLiteral();
                        VoidLiteral();
                    VarRefExpr(Id var) implements LHS;
                abstract Comprehension();
                    ArrayComprehension(List<ArrayComprehensionClause> clauses);
                    abstract GeneratedComprehension(List<Generator> gens);
                        SetComprehension(Expr element);
                        MapComprehension(Expr key, Expr value);
                        ListComprehension(Expr element);
                ChainExpr(Expr first, List<Pair<Op, Expr>> links);
                FieldSelection(Expr obj, Id id) implements LHS;
                LooseJuxt(List<Expr> exprs);
                TightJuxt(List<Expr> exprs);
                TypeApply(Expr expr, List<StaticArg> args);
            SubscriptExpr(Expr obj, List<Expr> subs, Option<Enclosing> op)
                                     implements LHS;
        /**
         *
         *
         * e.g.)
         */
        abstract UnitExpr();
            UnitRef(StaticArg val);
    /**
     *
     *
     * e.g.)
     */
    ExtentRange(Option<TypeRef> base, Option<TypeRef> size);
    /**
     * syntax expanders declaration in APIs
     * ExternalSyntax ::= syntax OpenExpander Id CloseExpander = Expr
     * e.g.) syntax sql e end = parseSQL(e)
     */
    ExternalSyntax(Name openExpander, Id id, Name closeExpander, Expr expr)
                  implements Decl, AbsDecl;
    abstract FnAbsDeclOrDecl(List<Modifier> mods, FnName fnName,
                             Option<List<StaticParam>> staticParams,
                             List<Param> params, Option<TypeRef> returnType,
                             List<TypeRef> throwsClause, List<WhereClause> where,
                             Contract contract)
                            implements Generic, Applicable, AbsDeclOrDecl;
        AbsFnDecl(String selfName) implements Decl, AbsDecl, Applicable;
        FnDecl(String selfName, Expr body) implements Decl, Applicable;
/*
 * Note well; because this is a useful abstraction for the
 * generalized names seen in Fortress, it will persist into
 * more semantically aware parts of the system (i.e., into
 * the interpreter, compiler, typechecker, etc).
 */
    abstract FnName();
        DottedId(List<String> names);
        Fun(Id name);
        Name(Option<Id> id, Option<Op> op);
        abstract OprName();
            /**
             * a pair of enclosing operators
             * EncloserPair ::= LeftEncloser RightEncloser
             * e.g.) </ />
             */
            Enclosing(Op open, Op close);
            Opr(Op op);
            PostFix(Op op);
            SubscriptAssign();
            SubscriptOp();
/**
 * Not part of the actual AST; constructed during evaluation of anonymous
 * functions to give them a name.
 */
            AnonymousFnName();
/**
 * Not part of the actual AST; constructed during evaluation of anonymous
 * functions to give them a name.
 */
            ConstructorFnName(AbsDeclOrDecl def);
    Generator(List<Id> bind, Expr init);
    Id(String name);
    IfClause(Expr test, Expr body);
    /**
     * import statement
     * Import ::= import ImportFrom | import AliasedDottedIds
     */
    abstract Import();
        /**
         * ImportFrom ::= * (except Names)? from DottedId
         *              | AliasedNames from DottedId
         */
        abstract ImportFrom(DottedId source);
            /**
             * e.g.) import * from Set
             */
            ImportStar(List<Name> except);
            /**
             * e.g.) import {empty, union} from Set
             */
            ImportNames(List<AliasedName> aliasedNames);
        /**
         * e.g.) import {Set, Map, List}
         */
        ImportApi(List<AliasedDottedId> apis);
    /**
     * array indices (Mismatch with the Spec!)
     */
    abstract Indices();
        /**
         * array dimensionality (Mismatch with the Spec!)
         * ArraySize ::= ExtentRange(, ExtentRange)*
         * e.g.) 3, 2#1, 3:5
         */
        FixedDim(List<ExtentRange> extents);
    /**
     * keyword type used in tuple types (Mismatch with the Spec!)
     * KeywordType ::= Id = TypeRef
     * e.g.) x = String
     */
    KeywordType(Id id, TypeRef type);
    /**
     * left-hand side of variable declaration
     */
    abstract LValue();
        /**
         * e.g.) var x: ZZ32
         */
        LValueBind(Id id, Option<TypeRef> type, List<Modifier> mods,
                   boolean mutable) implements LHS;
        /**
         * left-hand side of matrix unpasting
         * Unpasting ::= [ UnpastingElems ]
         */
        abstract Unpasting();
            /**
             * simple unpasting
             * UnpastingElem ::= Id ([ UnpastingDim ])?
             *                 | Unpasting
             * UnpastingDim ::= ExtentRange (BY ExtentRange)+
             * e.g.) squareShape[m BY m]
             */
            UnpastingBind(Id id, Option<List<ExtentRange>> dim);
            /**
             * complex unpasting
             * UnpastingElems ::= UnpastingElem RectSeparator UnpastingElems
             *                  | UnpastingElem
             * e.g.) squareShape[m BY m]  rest
             */
            UnpastingSplit(List<Unpasting> elems, int dim);
    /**
     * modifier
     */
    abstract Modifier();
        /**
         * e.g.) abstract m(x: ZZ32): ()
         */
        ModifierAbstract();
        /**
         * e.g.) atomic f(x: ZZ32): ()
         */
        ModifierAtomic();
        /**
         * e.g.) getter velocity(): (RR Velocity)^3
         */
        ModifierGetter();
        /**
         * e.g.) hidden x: ZZ32
         */
        ModifierHidden();
        /**
         * e.g.) io print(s: String): ()
         */
        ModifierIO();
        /**
         * e.g.) override m(x: ZZ32): ()
         */
        ModifierOverride();
        /**
         * e.g.) private f(): ()
         */
        ModifierPrivate();
        /**
         * e.g.) settable message: Maybe[\String\]
         */
        ModifierSettable();
        /**
         * e.g.) setter velocity(v: (RR Velocity)^3): ()
         */
        ModifierSetter();
        /**
         * e.g.) test object TestSuite(testFunctions = {}) end
         */
        ModifierTest();
        /**
         * e.g.) object O(transient x: ZZ32) end
         */
        ModifierTransient();
        /**
         * e.g.) value object IntEmpty extends List[\ZZ32\] end
         */
        ModifierValue();
        /**
         * e.g.) var x: ZZ32
         */
        ModifierVar();
        /**
         * e.g.) coerce (x: RR32) widens = ...
         */
        ModifierWidens();
        /**
         * e.g.) wrapped val: Dictionary[\T\]
         */
        ModifierWrapped();
    /**
     * object declaration in components or APIs
     */
    abstract ObjectAbsDeclOrDecl(List<Modifier> mods, Id id,
                                 Option<List<StaticParam>> staticParams,
                                 Option<List<Param>> params,
                                 Option<List<TypeRef>> extendsClause,
                                 List<TypeRef> throwsClause,
                                 List<WhereClause> where,
                                 Contract contract)
                                implements Generic, AbsDeclOrDecl;
        /**
         * object declaration in APIs
         * AbsObjectDecl ::= AbsObjectMods? ObjectHeader AbsGoInAnObject? end
         * ObjectHeader ::= object Id StaticParams? ObjectValParam? Extends?
         *                  FnClauses
         * e.g.) object Empty[\alph\]() extends List[\alpha\] end
         */
        AbsObjectDecl(List<? extends AbsDeclOrDecl> absDeclOrDecls)
                     implements GenericAbsDeclOrDeclWithParams, AbsDecl;
        /**
         * object declaration in components
         * ObjectDecl ::= ObjectMods? ObjectHeader GoInAnObject? end
         * e.g.) object Empty[\alph\]() extends List[\alpha\]
         *         length() = 0
         *       end
         */
        ObjectDecl(List<? extends AbsDeclOrDecl> absDeclOrDecls)
                  implements GenericDeclWithParams;
    Op(String name);
    Param(List<Modifier> mods, Id name, Option<TypeRef> type,
                Option<Expr> defaultExpr);
    PropertyDecl(Option<Id> id, List<Param> params, Expr expr)
                            implements Decl, AbsDecl;
    abstract StaticParam();
        BoolParam(Id id);
        DimensionParam(Id id);
        IntParam(Id id);
        NatParam(Id id);
        OperatorParam(Op op);
        SimpleTypeParam(Id id, Option<List<TypeRef>> extendsClause, boolean absorbs);
    TestDecl(Id id, List<Generator> gens, Expr expr) implements Decl, AbsDecl;
    /**
     * trait declaration in components or APIs
     */
    abstract TraitAbsDeclOrDecl(List<Modifier> mods, Id id,
                                Option<List<StaticParam>> staticParams,
                                Option<List<TypeRef>> extendsClause,
                                List<TypeRef> excludes,
                                Option<List<TypeRef>> comprises,
                                List<WhereClause> where,
                                List<? extends AbsDeclOrDecl> absDeclOrDecls)
                               implements Generic, HasWhere;
        /**
         * trait declaration in APIs
         * AbsTraitDecl ::= AbsTraitMods? TraitHeaderFront AbsTraitClauses
         *                  AbsGoInATrait? end
         * AbsTraitClause ::= Excludes | AbsComprises | Where
         * e.g.) trait List[\alpha\] comprises { Cons[\alpha\], Empty[\alpha\] }
         *         cons(x: alph): List[\alpha\]
         *       end
         */
        AbsTraitDecl() implements GenericAbsDeclOrDecl, AbsDecl;
        /**
         * trait declaration in components
         * TraitDecl ::= TraitMods? TraitHeaderFront TraitClauses GoInATrait? end
         * TraitHeaderFront ::= trait Id StaticParams? Extends?
         * TraitClause ::= Excludes | Comprises | Where
         * e.g.) trait List[\alpha\] comprises { Cons[\alpha\], Empty[\alpha\] }
         *         cons(x: alph): List[\alpha\] = Cons[\alph\](x, self)
         *       end
         */
        TraitDecl() implements GenericDecl;
    TypeCaseClause(List<TypeRef> match, List<Expr> body);
    abstract TypeRef();
        ArrowType(List<TypeRef> domain, TypeRef range,
                            List<TypeRef> throwsClause);
        abstract NonArrowType();
            abstract TraitType();
                ArrayType(TypeRef element, Indices indices);
                ListType(TypeRef element);
                MapType(TypeRef key, TypeRef value);
                MatrixType(TypeRef element, List<ExtentRange> dimensions);
                ParamType(TypeRef generic, List<StaticArg> args);
                VectorType(TypeRef element, ExtentRange dim);
            IdType(DottedId name);
            TupleType(List<TypeRef> elements, List<KeywordType> keywords);
            VarargsType(TypeRef type);
            VoidType();
            abstract DimType();
                DimRef(StaticArg val);
                ProductDimType(TypeRef multiplier, DimRef multiplicand);
                QuotientDimType(TypeRef numerator, DimRef denominator);
                ProductUnitType(TypeRef multiplier, UnitRef multiplicand);
                QuotientUnitType(TypeRef numerator, UnitRef denominator);
                DimTypeConversion(TypeRef type, DimRef dim);
        /**
         * NOTE: StaticArg extends TypeRef because there seems
         * to be an ambiguity here, since syntactically there is
         * not a good way to tell the products of typeargs for DimType
         * and natargs for StaticArg
         */
        abstract StaticArg();
            BaseNatRef(int value);
            BaseOprRef(FnName name);
            BaseDimRef();
            BaseUnitRef();
            abstract BoolRef();
                BaseBoolRef(boolean bool);
                NotBoolRef(StaticArg val);
                OrBoolRef(StaticArg left, StaticArg right);
                AndBoolRef(StaticArg left, StaticArg right);
                ImpliesBoolRef(StaticArg left, StaticArg right);
            abstract CompoundStaticArg();
                SumStaticArg(List<StaticArg> values);
                ProductStaticArg(List<StaticArg> values);
                QuotientStaticArg(TypeRef numerator, TypeRef denominator);
                ExponentStaticArg(TypeRef base, TypeRef power);
                DimensionStaticArg(StaticArg val, DimUnitOp op);
            TypeArg(TypeRef type);
    UnitDecl(List<Id> names, Option<TypeRef> type, Option<Expr> def, boolean si)
                    implements Decl;
    /**
     * variable declaration in components or APIs
     */
    abstract VarAbsDeclOrDecl(List<LValue> lhs) implements AbsDeclOrDecl;
        /**
         * variable declaration in APIs
         */
        AbsVarDecl() implements AbsDecl;
        /**
         * variable declaration in components
         */
        VarDecl(Expr init) implements Decl;
    abstract WhereClause();
        AbsTypeAlias(Id name, List<StaticParam> staticParams) implements AbsDecl;
        TypeAlias(Id name, List<StaticParam> staticParams, TypeRef type)
                         implements Decl;
        WhereBool(Id name);
        WhereExtends(Id name, List<TypeRef> supers);
        WhereNat(Id name);
        WhereUnit(Id name);
        WhereWidensCoerces(TypeRef first, TypeRef second);
end;
