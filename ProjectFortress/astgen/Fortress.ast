/*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

generateEmptyConstructor yes;   // for reflective object creation
visitMethod accept;
visitorMethodPrefix for;
addGetterPrefixes yes;
usePLT yes;
tabSize 4;
allowNulls no;
generateToString no;
generateEquals yes;
generateSerializers yes;

package com.sun.fortress.nodes;
import java.io.IOException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import com.sun.fortress.nodes_util.*;
import com.sun.fortress.useful.*;

begin ast;

/**
 * top-level node interface
 */
interface Node(ignoreForEquals Span span = new Span()) extends HasAt;
    /**
     * declaration in components or APIs
     */
    interface AbsDeclOrDecl();
        /**
         * declaration in APIs
         */
        interface AbsDecl();
        /**
         * declaration in components
         */
        interface Decl();
    /**
     * left-hand-side of assignments, local variable declarations, or
     * top-level declarations.
     */
    interface LHS();
    /**
     * with static parameters
     * implemented by TraitAbsDeclOrDecl, ObjectAbsDeclOrDecl and FnAbsDeclOrDecl
     */
    interface Generic(List<StaticParam> staticParams);
    /**
     * with value parameters
     * implemented by object declarations and object expressions
     */
    interface HasParams(Option<List<Param>> params,
                        List<? extends AbsDeclOrDecl> decls);
    /**
     * with a where clause
     * implemented by trait and object declarations in components or APIs
     */
    interface HasWhere(List<WhereClause> where);

/**
 * functional declaration or function expression
 * nodes_util.NodeUtil declares the following static methods:
 *  - String nameAsMethod(Applicable)
 *  - Option<Expr> getBody(Applicable)
 */
interface Applicable(FnName fnName, List<StaticParam> staticParams,
                     List<Param> params, Option<TypeRef> returnType,
                     List<WhereClause> where) extends HasAt;

/**
 * intersections of interface types
 */
interface GenericWithParams() extends Generic, HasParams;
interface GenericAbsDeclOrDecl() extends Generic, AbsDeclOrDecl;
    interface GenericDecl() extends Decl;
interface GenericAbsDeclOrDeclWithParams() extends GenericWithParams,
                                                   GenericAbsDeclOrDecl;
    interface GenericDeclWithParams() extends GenericDecl;

/**
 * top-level node abstract class
 */
abstract AbstractNode(ignoreForEquals Span span = new Span())
                     extends UIDObject implements Node;
    /**
     * compilation unit declaration
     * CompilationUnit ::= Component | Api
     */
    abstract CompilationUnit(DottedId dottedId, List<Import> imports);
        /**
         * component declaration
         * Component ::= component DottedId Imports? Exports Decls? end
         * e.g.) component Hello
         *         export Executable
         *         run(args:String...) = print "Hello, World!\n"
         *       end
         */
        Component(List<Export> exports, List<Decl> decls);
        /**
         * API declaration
         * Api ::= api DottedId Imports? AbsDecls? end
         * e.g.) api Executable
         *         run(args:String...):()
         *       end
         */
        Api(List<AbsDecl> decls);
    /**
     * import statement
     * Import ::= import ImportFrom | import AliasedDottedIds
     */
    abstract Import();
        /**
         * ImportFrom ::= * (except Names)? from DottedId
         *              | AliasedNames from DottedId
         * Name ::= Id
         *        | opr Op
         *        | opr EncloserPair
         */
        abstract ImportFrom(DottedId source);
            /**
             * e.g.) import * except {opr UNION, union} from Set
             */
            ImportStar(List<FnName> except);
            /**
             * e.g.) import {empty, union} from Set
             */
            ImportNames(List<AliasedName> aliasedNames);
        /**
         * e.g.) import {Set, Map, List}
         */
        ImportApi(List<AliasedDottedId> apis);
    /**
     * export statement
     * Export ::= export DottedIds
     * e.g.) export Executable
     */
    Export(List<DottedId> dottedIds);
    /**
     * aliased name used in import statements
     * AliasedName ::= Id (as DottedId)?
     *               | opr Op (as Op)?
     *               | opr EncloserPair (as EncloserPair)?
     * EncloserPair ::= LeftEncloser RightEncloser
     * e.g.) longComplexName as shortName
     */
    AliasedName(FnName fnName, Option<FnName> alias = None.<FnName>make());
    /**
     * aliased dotted id used in import statements
     * AliasedDottedId ::= DottedId (as DottedId)?
     * e.g.) com.sun.fortress.parser.precedence.resolver as precedence.resolver
     */
    AliasedDottedId(DottedId dottedId,
                    Option<DottedId> alias = None.<DottedId>make());
    /**
     * trait or object declaration in components or APIs
     */
    abstract TraitObjectAbsDeclOrDecl(List<Modifier> mods
                                          = Collections.<Modifier>emptyList(),
                                      Id id,
                                      List<StaticParam> staticParams
                                          = Collections.<StaticParam>emptyList(),
                                      List<TraitType> extendsClause
                                          = Collections.<TraitType>emptyList(),
                                      List<WhereClause> where
                                          = Collections.<WhereClause>emptyList(),
                                      List<? extends AbsDeclOrDecl> decls)
                                     implements HasWhere, GenericAbsDeclOrDecl;
        /**
         * trait declaration in components or APIs
         */
        abstract TraitAbsDeclOrDecl(List<TraitType> excludes
                                        = Collections.<TraitType>emptyList(),
                                    Option<List<TraitType>> comprises
                                        = None.<List<TraitType>>make(),
                                    List<? extends AbsDeclOrDecl> decls);
            /**
             * trait declaration in APIs
             * AbsTraitDecl ::= AbsTraitMods? TraitHeaderFront AbsTraitClauses
             *                  AbsGoInATrait? end
             * TraitHeaderFront ::= trait Id StaticParams? Extends?
             * AbsTraitClause ::= Excludes | AbsComprises | Where
             * Extends ::= extends TraitTypes
             * Excludes ::= excludes TraitTypes
             * AbsComprises ::= comprises ComprisingTypes
             * ComprisingTypes ::= TraitType | { ComprisingTypeList }
             * ComprisingTypeList ::= ...
             *                      | TraitType(, TraitType)*(, ...)?
             * AbsGoInATrait ::= AbsCoercions? AbsGoFrontInATrait AbsGoBackInATrait?
             *                 | AbsCoercions? AbsGoBackInATrait
             * AbsGoesFrontInATrait ::= ApiFldDecl
             *                        | AbsGetterSetterDecl
             *                        | PropertyDecl
             * AbsGoesBackInATrait  ::= AbsMdDecl
             *                        | PropertyDecl
             * e.g.) trait List[\alpha\] comprises {Cons[\alpha\],Empty[\alpha\]}
             *         cons(x: alph): List[\alpha\]
             *       end
             */
            AbsTraitDecl(List<AbsDecl> decls) implements AbsDecl;
            /**
             * trait declaration in components
             * TraitDecl ::= TraitMods? TraitHeaderFront TraitClauses GoInATrait?
             *                 end
             * TraitClause ::= Excludes | Comprises | Where
             * Comprises ::= comprises TraitTypes
             * GoInATrait ::= Coercions? GoFrontInATrait GoBackInATrait?
             *              | Coercions? GoBackInATrait
             * GoesFrontInATrait ::= AbsFldDecl
             *                     | GetterSetterDecl
             *                     | PropertyDecl
             * GoesBackInATrait  ::= MdDecl
             *                     | PropertyDecl
             * e.g.) trait List[\alpha\] comprises {Cons[\alpha\],Empty[\alpha\]}
             *         cons(x: alph): List[\alpha\] = Cons[\alph\](x, self)
             *       end
             */
            TraitDecl(List<Decl> decls) implements GenericDecl;
        /**
         * object declaration in components or APIs
         */
        abstract ObjectAbsDeclOrDecl(Option<List<Param>> params
                                         = None.<List<Param>>make(),
                                     Option<List<TraitType>> throwsClause
                                         = None.<List<TraitType>>make(),
                                     Contract contract = new Contract(),
                                     List<? extends AbsDeclOrDecl> decls)
                                    implements GenericAbsDeclOrDeclWithParams;
            /**
             * object declaration in APIs
             * AbsObjectDecl ::= AbsObjectMods? ObjectHeader AbsGoInAnObject? end
             * ObjectHeader ::= object Id StaticParams? ObjectValParam? Extends?
             *                  FnClauses
             * FnClauses ::= Throws? Where? Contract
             * Throws ::= throws MayTraitTypes
             * ObjectValParam ::= ( ObjectParams? )
             * ObjectParams ::= (ObjectParam ,)* (ObjectVarargs, )? ObjectKeyword(, ObjectKeyword)*
             *                | (ObjectParam ,)* ObjectVarargs
             *                | ObjectParam (, ObjectParam)*
             * ObjectVarargs ::= transient Varargs
             * ObjectKeyword ::= ObjectParam = Expr
             * ObjectParam ::= ParamFldMods? Param
             *               | transient Param
             * AbsGoInAnObject ::= AbsCoercions? AbsGoFrontInAnObject AbsGoBackInAnObject?
             *                   | AbsCoercions? AbsGoBackInAnObject
             * AbsGoesFrontInAnObject ::= ApiFldDecl
             *                          | AbsGetterSetterDecl
             *                          | PropertyDecl
             * AbsGoesBackInAnObject ::= AbsMdDecl
             *                         | PropertyDecl
             * e.g.) object Empty[\alph\]() extends List[\alpha\] end
             */
            AbsObjectDecl(List<AbsDecl> decls) implements AbsDecl;
            /**
             * object declaration in components
             * ObjectDecl ::= ObjectMods? ObjectHeader GoInAnObject? end
             * GoInAnObject ::= Coercions? GoFrontInAnObject GoBackInAnObject?
             *                | Coercions? GoBackInAnObject
             * GoesFrontInAnObject ::= FldDecl
             *                       | GetterSetterDecl
             *                       | PropertyDecl
             * GoesBackInAnObject ::= MdDecl
             *                      | PropertyDecl
             * e.g.) object Empty[\alph\]() extends List[\alpha\]
             *         length() = 0
             *       end
             */
            ObjectDecl(List<Decl> decls)
                      implements GenericDeclWithParams;
    /**
     * variable declaration in components or APIs
     */
    abstract VarAbsDeclOrDecl(List<LValueBind> lhs) implements AbsDeclOrDecl;
        /**
         * variable declaration in APIs
         * AbsVarDecl ::= AbsVarMods? VarWTypes
         *              | AbsVarMods? IdOrIdTuple : TypeRef ...
         *              | AbsVarMods? IdOrIdTuple : SimpleTupleType
         * VarWTypes ::= VarWType | ( VarWType(, VarWType)+ )
         * VarWType ::= Id IsType
         * e.g.) var (x, y): ZZ64...
         */
        AbsVarDecl() implements AbsDecl, Decl;
        /**
         * variable declaration in components
         * VarDecl ::= VarMods? VarWTypes InitVal
         *           | VarMods? IdOrIdTuple = Expr
         *           | VarMods? IdOrIdTuple : TypeRef ... InitVal
         *           | VarMods? IdOrIdTuple : SimpleTupleType InitVal
         * InitVal ::= (= | :=) Expr
         * e.g.) var (x, y): ZZ64... = (5, 6)
         */
        VarDecl(Expr init) implements Decl;
    /**
     * left-hand side of variable declaration
     */
    abstract LValue();
        /**
         * e.g.) var x: ZZ32
         */
        LValueBind(Id id, Option<TypeRef> type = None.<TypeRef>make(),
                   List<Modifier> mods = Collections.<Modifier>emptyList(),
                   boolean mutable) implements LHS;
        /**
         * left-hand side of matrix unpasting
         * Unpasting ::= [ UnpastingElems ]
         */
        abstract Unpasting();
            /**
             * simple unpasting
             * UnpastingElem ::= Id ([ UnpastingDim ])?
             *                 | Unpasting
             * UnpastingDim ::= ExtentRange (BY ExtentRange)+
             * e.g.) squareShape[m BY m]
             */
            UnpastingBind(Id id, List<ExtentRange> dim);
            /**
             * complex unpasting
             * UnpastingElems ::= UnpastingElem RectSeparator UnpastingElems
             *                  | UnpastingElem
             * e.g.) squareShape[m BY m]  rest
             */
            UnpastingSplit(List<Unpasting> elems, int dim);
    /**
     * functional declaration in components or APIs
     */
    abstract FnAbsDeclOrDecl(List<Modifier> mods
                                 = Collections.<Modifier>emptyList(),
                             FnName fnName,
                             List<StaticParam> staticParams
                                 = Collections.<StaticParam>emptyList(),
                             List<Param> params,
                             Option<TypeRef> returnType
                                 = None.<TypeRef>make(),
                             Option<List<TraitType>> throwsClause
                                 = None.<List<TraitType>>make(),
                             List<WhereClause> where
                                 = Collections.<WhereClause>emptyList(),
                             Contract contract = new Contract(),
                             String selfName = NodeUtil.defaultSelfName)
                            implements Applicable, GenericDecl;
        /**
         * functional declaration in APIs
         * AbsFnDecl ::= AbsFnMods? FnHeaderFront FnHeaderClause
         *             | FnSig
         * FnSig ::= Name : ArrowType
         * FnHeaderFront ::= Id StaticParams? ValParam
         *                 | OpHeaderFront
         * OpHeaderFront ::= opr StaticParams? (LeftEncloser | Encloser) Params
         *                     (RightEncloser | Encloser)
         *                     (:= ( SubscriptAssignParam ))?
         *                 | opr StaticParams? ValParam Op
         *                 | opr (Op | ExponentOp | Encloser) StaticParams? ValParam
         * SubscriptAssignParam ::= Varargs | Param
         * FnHeaderClause ::= IsType? FnClauses
         * FnDecl ::= FnMods? FnHeaderFront FnHeaderClause
         *          | FnSig
         * e.g.) swap (x: Object, y: Object): (Object, Object)
         */
        AbsFnDecl() implements AbsDecl;
        /**
         * functional declaration in components
         * FnDecl ::= FnMods? FnHeaderFront FnHeaderClause = Expr
         * e.g.) swap (x, y) = (y, x)
         */
        abstract FnDecl();
            FnDef(Expr body);
    /**
     * value parameter of functional declarations and object declarations
     * e.g.) x: ZZ32 = 3
     * e.g.) self
     * e.g.) transient x: String
     */
    abstract Param(List<Modifier> mods = Collections.<Modifier>emptyList(),
                   Id id);
        /**
         * ValParam := Id
         *           | (Params?)
         * Params ::= (Param, )* (Varargs, )? Keyword(, Keyword)*
         *          | (Param, )* Varargs
         *          | Param(, Param)*
         *
         * Keyword ::= Param = Expr
         * PlainParam ::= Id IsType?
         *              | TypeRef
         */
        NormalParam(Option<TypeRef> type = None.<TypeRef>make(),
                    Option<Expr> defaultExpr = None.<Expr>make());
        /**
         * varargs parameter
         * VarargsParam ::= Id : TypeRef ...
         */
        VarargsParam(VarargsType varargsType);
    /**
     * dimension declaration (Not Yet Implemented in the Parser!)
     * DimUnitDecl ::= dim Id (= DimRef)? (default Id)?
     *               | (unit | SI_unit) Id+ (: DimRef)? (= Expr)?
     *               | dim Id (= DimRef)? (unit | SI_unit) Id+ (= Expr)?
     * e.g.) dim Length SI_unit meter meters m
     */
    DimDecl(Id id, Option<TypeRef> derived = None.<TypeRef>make(),
            Option<TypeRef> default = None.<TypeRef>make())
           implements Decl, AbsDecl;
    /**
     * unit declaration (Not Yet Implemented in the Parser!)
     * DimUnitDecl ::= dim Id ( = DimRef )? ( default Id)?
     *               | ( unit | SI_unit ) Id+ ( : DimRef )? ( = Expr)?
     *               | dim Id ( = DimRef )? ( unit | SI_unit ) Id+ ( = Expr)?
     * e.g.) unit inch inches: Length
     */
    UnitDecl(List<Id> names, Option<TypeRef> type = None.<TypeRef>make(),
             Option<Expr> def = None.<Expr>make(), boolean si)
            implements Decl, AbsDecl;
    /**
     * test declaration
     * TestDecl ::= test Id [GeneratorList] = Expr
     * e.g.) test fxLessThanFy[x <- E, y <- F] = assert(f(x) < f(y))
     */
    TestDecl(Id id, List<Generator> gens, Expr expr) implements Decl, AbsDecl;
    /**
     * property declaration
     * PropertyDecl ::= property (Id = )? (FORALL ValParam)? Expr
     * e.g.) property fIsMonotonic = FORALL (x:ZZ, y:ZZ) (x < y) -> (f(x) < f(y))
     */
    PropertyDecl(Option<Id> id = None.<Id>make(), List<Param> params, Expr expr)
                implements Decl, AbsDecl;
    /**
     * syntax expanders declaration in components or APIs
     */
    abstract ExternalSyntaxAbsDeclOrDecl(FnName openExpander, Id id,
                                         FnName closeExpander)
                                        implements AbsDeclOrDecl;
        /**
         * syntax expanders declaration in APIs
         * AbsExternalSyntax ::= syntax OpenExpander Id CloseExpander
         * OpenExpander ::= Id
         *                | LeftEncloser
         * CloseExpander ::= Id
         *                 | RightEncloser
         *                 | end
         * e.g.) syntax sql e end
         */
        AbsExternalSyntax() implements AbsDecl;
        /**
         * syntax expanders declaration in APIs
         * ExternalSyntax ::= syntax OpenExpander Id CloseExpander = Expr
         * e.g.) syntax sql e end = parseSQL(e)
         */
        ExternalSyntax(Expr expr) implements Decl;
    /**
     * expression
     */
    abstract Expr(boolean parenthesized = false);
        /**
         * type ascription expression
         * Expr ::= Expr as TypeRef
         * e.g.) 3 as Number
         */
        AsExpr(Expr expr, TypeRef type);
        /**
         * type assumption expression
         * Expr ::= Expr asif TypeRef
         * e.g.) Empty asif List[\String\]
         */
        AsIfExpr(Expr expr, TypeRef type);
        /**
         * assignment expression
         * Expr ::= AssignLefts AssignOp Expr
         * AssignLefts ::= ( AssignLeft(, AssignLeft)* )
         *               | AssignLeft
         * AssignLeft ::= SubscriptExpr
         *              | MemberSelection
         *              | Id
         * AssignOp ::= := | Op=
         * e.g.) x += 1
         */
        Assignment(List<LHS> lhs, Option<Op> op, Expr rhs);
        /**
         * expressions beginning and ending with reserved words
         * Expr ::= DelimitedExpr
         */
        abstract DelimitedExpr();
            /**
             * sequence of block elements implicitly enclosed by do/end
             * BlockElems ::= BlockElem+
             * e.g.) y = x
             *       z = 2x
             *       y + z
             */
            Block(List<Expr> exprs);
            /**
             * case expression or extremum expression
             * DelimitedExpr ::= case Expr Op? of CaseClauses CaseElse? end
             *                 | case largest Op? of CaseClauses end
             *                 | case smallest Op? of CaseClauses end
             * CaseElse ::= else => BlockElems
             * e.g.) case largest of
             *         1 mile => "miles are larger"
             *         1 kilometer => "we were wrong again"
             *       end
             */
            CaseExpr(CaseParam param, Option<Op> compare = None.<Op>make(),
                     List<CaseClause> clauses,
                     Option<Block> elseClause = None.<Block>make());
            /**
             * do expression
             * Do ::= (DoFront also)* DoFront end
             * e.g.) do
             *         accum += treeSum(t.left)
             *       also do
             *         accum += treeSum(t.right)
             *       also do
             *         accum += t.datum
             *       end
             */
            Do(List<DoFront> fronts);
            /**
             * for expression
             * DelimitedExpr ::= for GeneratorList DoFront end
             * e.g.) for i <- sequential(1:5) do
             *         print (i " ")
             *       end
             */
            For(List<Generator> gens, DoFront body);
            /**
             * if expression
             * DelimitedExpr ::= if Expr then BlockElems Elifs? Else? end
             *                 | ( if Expr then blockElems Elifs? Else end? )
             * Elif ::= elif Expr then BlockElems
             * Else ::= else BlockElems
             * e.g.) if x IN {0, 1, 2} then 0
             *       elif x IN {3, 4, 5} then 3
             *       else 6 end
             */
            If(List<IfClause> clauses,
               Option<Block> elseClause = None.<Block>make());
            /**
             * label expression
             * DelimitedExpr ::= label Id BlockElems end Id
             * e.g.) label I_95
             *         if goingTo(Sun)
             *         then exit I_95 with x32B
             *         else x32A
             *         end
             *       end I_95
             */
            Label(Id id, Block body);
            /**
             * object expression
             */
            abstract AbstractObjectExpr(List<TraitType> extendsClause
                                            = Collections.<TraitType>emptyList(),
                                        List<Decl> decls);
                /**
                 * object expression
                 * DelimitedExpr ::= object Extends? GoInAnObject end
                 * e.g.)  object extends {List}
                 *          cons(x) = Cons(x, self)
                 *          append (xs) = xs
                 *        end
                 */
                ObjectExpr();
                /**
                 * object expression rewritten by interpreter.rewrite.Disambiguate
                 */
                _RewriteObjectExpr(BATree<String, StaticParam> implicitTypeParameters,
                                   String genSymName,
                                   List<StaticParam> staticParams,
                                   List<StaticArg> staticArgs,
                                   Option<List<Param>> params)
                                  implements GenericWithParams;
            /**
             * try expression
             * DelimitedExpr ::= try BlockElems Catch? (forbid TraitTypes)?
             *                     (finally BlockElems)? end
             * e.g.) try
             *         inp = read (file)
             *         write (inp, newFile)
             *       forbid IOException
             *       end
             */
            Try(Block body, Option<Catch> catchClause = None.<Catch>make(),
                List<TraitType> forbid = Collections.<TraitType>emptyList(),
                Option<Block> finallyClause = None.<Block>make());
            /**
             * tuple expression
             * TupleExpr ::= ( (Expr,)*  (Expr...,)? Binding(, Binding)* )
             *             | NoKeyTuple
             * NoKeyTuple ::= ( (Expr,)* Expr... )
             *              | ( (Expr,)+ Expr )
             * e.g.) (1, 2, [3 4]..., x = 5)
             */
            TupleExpr(List<Expr> exprs,
                      Option<VarargsExpr> varargs = None.<VarargsExpr>make(),
                      List<Binding> keywords = Collections.<Binding>emptyList());
            /**
             * typecase expression
             * DelimitedExpr ::= typecase TypecaseBindings of TypecaseClauses
             *                     CaseElse? end
             * TypecaseBindings ::= ( BindgingList )
             *                    | Binding
             *                    | Id
             * e.g.) typecase x = myLoser .myField of
             *         String => x.append("foo")
             *         Number => x + 3
             *         Object => yogiBerraAutograph
             *       end
             */
            Typecase(List<Binding> bind, List<TypecaseClause> clauses,
                     Option<Block> elseClause = None.<Block>make());
            /**
             * while expression
             * DelimitedExpr ::= while Expr Do
             * e.g.) while x < 10 do print x; x += 1 end
             */
            While(Expr test, Do body);
        /**
         * control flow expression
         * Expr ::= FlowExpr
         */
        abstract FlowExpr();
            /**
             * summation and other reduction expression
             * FlowExpr ::= Accumulator ([ GeneratorList ])? Expr
             * Accumulator ::= SUM | PRODUCT | Big Op
             * e.g.) PRODUCT[i <- 1:n] i
             */
            Accumulator(Op op, List<Generator> gens, Expr body);
            /**
             * atomic expression
             * FlowExpr ::= atomic AtomicBack
             * AtomicBack ::= AssignLefts AssignOp Expr
             *              | OpExpr
             *              | DelimitedExpr
             * e.g.) atomic sum += a[i]
             */
            AtomicExpr(Expr expr);
            /**
             * exiting labeled expressions
             * FlowExpr ::= exit Id? (with Expr)?
             * e.g.) exit I_95 with x32B
             */
            Exit(Option<Id> optId = None.<Id>make(),
                 Option<Expr> returnExpr = None.<Expr>make());
            /**
             * spawn expression
             * FlowExpr ::= spawn Expr
             * e.g.) spawn mm(lefttop, right, resulttop)
             */
            Spawn(Expr body);
            /**
             * throw expression
             * FlowExpr ::= throw Expr
             * e.g.) throw Error
             */
            Throw(Expr expr);
            /**
             * tryatomic expression
             * FlowExpr ::= tryatomic AtomicBack
             * e.g.) tryatomic sum += a[i]
             */
            TryAtomicExpr(Expr expr);
        /**
         * function expression
         * Expr ::= fn ValParam IsType? Throws? => Expr
         * e.g.) fn x => x + 2
         */
        FnExpr(ignoreForEquals Span span, // no default -- required to produce a fnName
               boolean parenthesized = false,
               FnName fnName = new AnonymousFnName(in_span),
               List<StaticParam> staticParams
                   = Collections.<StaticParam>emptyList(),
               List<Param> params,
               Option<TypeRef> returnType = None.<TypeRef>make(),
               List<WhereClause> where = Collections.<WhereClause>emptyList(),
               Option<List<TraitType>> throwsClause
                   = None.<List<TraitType>>make(),
               Expr body)
              implements Applicable;
        /**
         * expression used in block expressions
         * BlockElem ::= LocalVarFnDecl
         *             | Expr(, GeneratorList)?
         * LocalVarFnDecl ::= LocalFnDecl+
         *                  | LocalVarDecl
         */
        abstract LetExpr(List<Expr> body);
            /**
             * generated expression
             * BlockElem ::= Expr(, GeneratorList)?
             * e.g.) print (i " "), i <- sequential(1:5)
             */
            GeneratedExpr(Expr expr, List<Generator> gens);
            /**
             * local function declaration
             * LocalFnDecl ::= LocalFnMods? FnHeaderFront FnHeaderClause = Expr
             * e.g.) localFn(x: ZZ32) = x + 2
             */
            LetFn(List<FnDef> fns);
            /**
             * local variable declaration
             * LocalVarDecl ::= var? LocalVarWTypes InitVal
             *                | var? LocalVarWTypes
             *                | var? LocalVarWoTypes = Expr
             *                | var? LocalVarWoTypes : TypeRef ... InitVal?
             *                | var? LocalVarWoTypes : SimpleTupleType InitVal?
             * LocalVarWTypes ::= LocalVarWType
             *                  | ( LocalVarWType(, LocalVarWType)+ )
             * LocalVarWType ::= Id IsType
             * LocalVarWoTypes ::= LocalVarWoType
             *                   | ( LocalVarWoType(, LocalVarWoType)+ )
             * LocalVarWoType ::= Id
             *                  | Unpasting
             * e.g.) localVar x = 3
             */
            LocalVarDecl(List<LValue> lhs, Option<Expr> rhs = None.<Expr>make());
        /**
         * expression that is simple or using operators
         * Expr ::= OpExpr
         */
        abstract OpExpr();
            /**
             * expression using operators
             * OpExpr ::= EncloserOp OpExpr? EncloserOp?
             *          | OpExpr EncloserOp OpExpr?
             *          | Primary
             * EncloserOp ::= Encloser
             *              | Op
             * Primary ::= LeftEncloser ExprList? RightEncloser
             *           | Primary ^ BaseExpr
             *           | Primary ExponentOp
             * e.g.) 3 + 5
             */
            OprExpr(OprName op,
                    List<Expr> args = Collections.<Expr>emptyList());
            /**
             * subscripting expression
             * SubscriptExpr ::= Primary [ ExprList? ]
             *                 | Primary LeftEncloser ExprList? RightEncloser
             * e.g.) a[i]
             */
            SubscriptExpr(Expr obj, List<Expr> subs,
                          Option<Enclosing> op = None.<Enclosing>make())
                         implements LHS;
            /**
             * primary expression
             */
            abstract Primary();
                /**
                 * functional application
                 * Primary ::= Primary . Id ([\StaticArgList\])? Parenthesized
                 *           | Primary . Id ([\StaticArgList\])? ()
                 *           | Primary Parenthesized
                 *           | Primary ()
                 *           | Primary Primary
                 * e.g.) myString.replace("foo", "few")
                 * e.g.) log log n
                 */
                Apply(Expr fn, Expr arg);
                /**
                 * coercion invocation
                 * internal node created by static analysis
                 * after inferring the implicit coercion invocations
                 */
                CoercionInvocation(TraitType type,
                                   List<StaticArg> staticArgs
                                       = Collections.<StaticArg>emptyList(),
                                   Expr arg);
                /**
                 * internal node created by static analysis
                 * after disambiguating method invocations and field accesses
                 */
                MethodInvocation(Expr obj, Id id,
                                 List<StaticArg> staticArgs
                                     = Collections.<StaticArg>emptyList(),
                                 Expr arg);
                /**
                 * field selection expression
                 * Primary ::= Primary . Id
                 * e.g.) Empty.length
                 */
                MemberSelection(Expr obj, Id id) implements LHS;
                /**
                 * juxtaposition of expressions
                 */
                abstract Juxt(List<Expr> exprs);
                    /**
                     * juxtaposition with intervening whitespace
                     * e.g.) 3 5
                     */
                    LooseJuxt();
                    /**
                     * juxtaposition without intervening whitespace
                     * e.g.) f(3+5)
                     */
                    TightJuxt();
                /**
                 * chain expression
                 * Certain infix mathematical operators that are traditionally
                 * regarded as relational operators, delivering boolean results,
                 * may be chained.
                 * e.g.) A SUBSETEQ B SUBSET C SUBSETEQ D
                 */
                ChainExpr(Expr first, List<Pair<Op, Expr>> links);
                /**
                 * expression with static instantiations
                 * Primary ::= Id[\StaticArgList\]
                 * e.g.) identity[\String\]
                 */
                FnRef(Expr expr,
                      List<StaticArg> staticArgs =
                          Collections.<StaticArg>emptyList());
                /**
                 * simple expression
                 * Primary ::= BaseExpr
                 */
                abstract BaseExpr();
                    /**
                     * variable reference
                     * BaseExpr ::= Id
                     *            | self
                     * e.g.) length
                     */
                    VarRef(Id var) implements LHS;
                    /**
                     * literal
                     * BaseExpr ::= Literal
                     */
                    abstract Literal(String text);
                        /**
                         * number literal
                         */
                        abstract NumberLiteral();
                            /**
                             * float literal
                             * e.g.) 3.5
                             */
                            FloatLiteral(ignoreForEquals String text,
                                         BigInteger intPart,
                                         BigInteger numerator, int denomBase,
                                         int denomPower);
                            /**
                             * int literal
                             * e.g.) 7
                             */
                            IntLiteral(String text = in_val.toString(),
                                       BigInteger val);
                        /**
                         * char literal
                         * e.g.) 'c'
                         */
                        CharLiteral(int val = in_text.charAt(0));
                        /**
                         * string literal
                         * e.g.) "string"
                         */
                        StringLiteral();
                        /**
                         * void literal
                         * e.g.) ()
                         */
                        VoidLiteral(String text = "");
                    /**
                     * aggregate expression
                     * BaseExpr ::= Aggregate
                     */
                    abstract Aggregate();
                        /**
                         * map expression
                         * Aggregate ::= { Entry (, Entry)* }
                         * e.g.) { 'a' |-> 0, 'b' |-> 1, 'c' |-> 2 }
                         */
                        MapExpr(List<Entry> elements);
                        /**
                         * array expression
                         * Aggregate ::= [ RectElements ]
                         * RectElements ::= Expr MultiDimCons*
                         * MultiDimCons ::= RectSeparator Expr
                         * RectSeparator ::= ;+
                         *                 | Whitespace
                         * e.g.) [1 2 3; 4 5 6; 7 8 9]
                         */
                        abstract ArrayExpr();
                            /**
                             * array with a single element
                             * e.g.) [3]
                             */
                            ArrayElement(Expr element);
                            /**
                             * array with multiple elements
                             * e.g.) [3 4 5; 6 7 8]
                             */
                            ArrayElements(int dimension,
                                          List<ArrayExpr> elements);
                /**
                 * comprehension expression
                 * Primary ::= Comprehension
                 */
                abstract Comprehension();
                    /**
                     * array comprehension
                     * Comprehension ::= [ ArrayComprehensionClause+ ]
                     * e.g.) [(x, y, 1) |-> 0.0 | x <- 1:xSize, y <- 1:ySize ]
                     */
                    ArrayComprehension(List<ArrayComprehensionClause> clauses);
                    /**
                     * comprehension with generators
                     */
                    abstract GeneratedComprehension(List<Generator> gens);
                        /**
                         * set comprehension
                         * Comprehension ::= { Expr | GeneratorList }
                         * e.g.) { x^2 | x <- {0, 1, 2, 3, 4, 5}, x MOD 2 = 0 }
                         */
                        SetComprehension(Expr element);
                        /**
                         * map comprehension
                         * Comprehension ::= { Entry | GeneratorList }
                         * e.g.) { x^2 |-> x^3 | x <- {0, 1, 2, 3, 4, 5} }
                         */
                        MapComprehension(Entry entry);
                        /**
                         * list comprehension
                         * Comprehension ::= <| Expr | GeneratorList |>
                         * e.g.)
                         */
                        ListComprehension(Expr element);
        /**
         * unit expression representing units
         */
        abstract UnitExpr();
            /**
             * unit quantity
             * UnitRef ::= StaticArg
             * e.g.) grams per cubic centimeter
             */
            UnitRef(StaticArg val);
    /**
     * type
     * TypeRef ::= ArrowType
     *           | NonArrowType
     */
    abstract TypeRef();
        /**
         * arrow type (Mismatch with the Spec!)
         * ArrowType ::= NonArrowType -> NonArrowType Throws?
         * e.g.) (String, NN..., p = Printer) -> NN throws IOException
         */
        ArrowType(List<TypeRef> domain, NonArrowType range,
                  Option<List<TraitType>> throwsClause);
        /**
         * nonarrow type
         */
        abstract NonArrowType();
            /**
             * trait type
             */
            abstract TraitType();
                /**
                 * array type
                 * TraitType ::= TypeRef [ ArraySize? ]
                 * e.g.) ZZ64[3, 2]
                 */
                ArrayType(TypeRef element, Indices indices);
                /**
                 * type name
                 * TraitType ::= DottedId
                 * e.g.) T
                 */
                IdType(DottedId dottedId);
                /**
                 * matrix type
                 * TraitType ::= TypeRef ^ StaticArg
                 *             | TypeRef ^ ( ExtentRange (BY ExtentRange)* )
                 * e.g.)
                 */
                MatrixType(TypeRef element, List<ExtentRange> dimensions);
                /**
                 * instantiated type
                 * TraitType ::= DottedId [\StaticArgList\]
                 * e.g.) List[\ZZ32\]
                 */
                InstantiatedType(DottedId dottedId, List<StaticArg> args);
            /**
             * tuple type
             * TupleType ::= ( (TypeRef, )* (TypeRef ... ,)? KeywordType(, KeywordType)* )
             *             | ( (TypeRef, )*  TypeRef ... )
             *             | SimpleTupleType
             * SimpleTupleType ::= ( TypeRef, TypeRefList )
             * e.g.)
             */
            TupleType(List<TypeRef> elements,
                      Option<VarargsType> varargs = new None<VarargsType>(),
                      List<KeywordType> keywords
                          = Collections.<KeywordType>emptyList());
            /**
             * void type
             * NonArrowType ::= ()
             * e.g.) ()
             */
            VoidType();
            /**
             * dimension type
             */
            abstract DimType();
                /**
                 * dimension quantity
                 * DimRef ::= StaticArg
                 * e.g.) 3
                 */
                DimRef(StaticArg val);
                /**
                 * dimension multiplication
                 * DimType ::= TypeRef DimRef
                 * e.g.) Velocity Time
                 */
                ProductDimType(TypeRef multiplier, DimRef multiplicand);
                /**
                 * dimension division
                 * DimType ::= TypeRef / DimRef
                 *           | TypeRef per DimRef
                 * e.g.) Velocity / Time
                 */
                QuotientDimType(TypeRef numerator, DimRef denominator);
                /**
                 * unit multiplication
                 * DimType ::= TypeRef UnitRef
                 * e.g.) m v^2
                 */
                ProductUnitType(TypeRef multiplier, UnitRef multiplicand);
                /**
                 * unit division
                 * DimType ::= TypeRef / UnitRef
                 *           | TypeRef per UnitRef
                 * e.g.) meters/seconds
                 */
                QuotientUnitType(TypeRef numerator, UnitRef denominator);
                /**
                 * dimension type conversion
                 * DimType ::= TypeRef in DimRef
                 * e.g.) f/s in m/s
                 */
                DimTypeConversion(TypeRef type, DimRef dim);
        /**
         * static argument
         * NOTE: StaticArg extends TypeRef because there seems to be an
         * ambiguity here, since syntactically there is not a good way to tell
         * the products of typeargs for DimType and natargs for StaticArg
         */
        abstract StaticArg();
            /**
             * number used as static argument
             * StaticArg ::= Number
             * Number ::= IntLiteral
             * e.g.) 5
             */
            BaseNatRef(int value);
            /**
             * operator used as static argument
             * StaticArg ::= Op
             * e.g.) +
             */
            BaseOprRef(FnName fnName);
            /**
             * dimension representing dimensionless
             * StaticArg ::= Unity
             * e.g.) Unity
             */
            BaseDimRef();
            /**
             * dimensionless unit
             * StaticArg ::= dimensionless
             * e.g.) dimensionless
             */
            BaseUnitRef();
            /**
             * boolean used as static argument
             */
            abstract BoolRef();
                /**
                 * boolean constant
                 * StaticArg ::= true | false
                 * e.g.) true
                 */
                BaseBoolRef(boolean bool);
                /**
                 * boolean negation
                 * StaticArg ::= NOT StaticArg
                 * e.g.) NOT ninf
                 */
                NotBoolRef(StaticArg val);
                /**
                 * boolean disjunction
                 * StaticArg ::= StaticArg OR StaticArg
                 * e.g.) ninf OR pinf
                 */
                OrBoolRef(StaticArg left, StaticArg right);
                /**
                 * boolean conjunction
                 * StaticArg ::= StaticArg AND StaticArg
                 * e.g.) ninf AND pinf
                 */
                AndBoolRef(StaticArg left, StaticArg right);
                /**
                 * boolean implication
                 * StaticArg ::= StaticArg IMPLIES StaticArg
                 * e.g.) gt AND eq IMPLIES ge
                 */
                ImpliesBoolRef(StaticArg left, StaticArg right);
            /**
             * static argument with operation
             */
            abstract CompoundStaticArg();
                /**
                 * summation of static arguments
                 * StaticArg ::= StaticArg + StaticArg
                 * e.g.) len + 2
                 */
                SumStaticArg(List<StaticArg> values);
                /**
                 * multiplication of static arguments
                 * StaticArg ::= StaticArg StaticArg
                 * e.g.) a + m c < n
                 */
                ProductStaticArg(List<StaticArg> values);
                /**
                 * division of static arguments
                 * StaticArg ::= StaticArg / StaticArg
                 *             | 1 / StaticArg
                 *             | StaticArg per StaticArg
                 * e.g.) kilograms per cubic meter
                 */
                QuotientStaticArg(TypeRef numerator, TypeRef denominator);
                /**
                 * exponentiation of static arguments
                 * StaticArg ::= StaticArg ^ StaticArg
                 * e.g.) Length ^ 3
                 */
                ExponentStaticArg(TypeRef base, TypeRef power);
                /**
                 * static argument with dimension operation
                 * StaticArg ::= DUPreOp StaticArg
                 *             | StaticArg DUPostOp
                 * e.g.) meters per second squared
                 */
                DimensionStaticArg(StaticArg val, DimUnitOp op);
            /**
             * type as static argument
             * StaticArg ::= TypeRef
             * e.g.) List[\ZZ64\]
             */
            TypeArg(TypeRef type);
    /**
     * where clause used in trait, object, and functional declarations
     * Where ::= where { WhereClauseList }
     * e.g.) where { ninf AND NOT nan }
     */
    abstract WhereClause();
        /**
         * type alias declaration
         * TypeAlias ::= type Id StaticParams? = TypeRef
         * e.g.) type IntList = List[\ZZ64\]
         */
        TypeAlias(Id id,
                  List<StaticParam> staticParams
                      = Collections.<StaticParam>emptyList(),
                  TypeRef type)
                 implements Decl, AbsDecl;
        /* bool parameter declared in where clauses
         * WhereClause ::= bool Id
         * e.g.) bool ninf
         */
        WhereBool(Id id);
        /* hidden type variable declared in where clauses
         * WhereClause ::= Id Extends
         * e.g.) T extends Object
         */
        WhereExtends(Id id, List<TraitType> supers);
        /* nat parameter declared in where clauses
         * WhereClause ::= nat Id
         * e.g.) nat length
         */
        WhereNat(Id id);
        /* unit parameter declared in where clauses
         * WhereClause ::= unit Id
         * e.g.) unit U
         */
        WhereUnit(Id id);
        /* coercion constraint declared in where clauses
         * WhereClause ::= TypeRef coerces TypeRef
         * e.g.) T coerces Identity[\ODOT\]
         */
        WhereCoerces(TypeRef first, TypeRef second);
        /* widening constraint declared in where clauses
         * WhereClause ::= TypeRef widens TypeRef
         * e.g.) T widens S
         */
        WhereWidens(TypeRef first, TypeRef second);
        /* widening coercion constraint declared in where clauses
         * WhereClause ::= TypeRef widens or coerces TypeRef
         * e.g.) T widens or coerces S
         */
        WhereWidensCoerces(TypeRef first, TypeRef second);
        /* compound constraint declared in where clauses
         * WhereClause ::= StaticArg
         * e.g.) where {lt AND eq AND gt, U = dimensionless}
         */
        WhereConstraint(StaticArg constraint);
    /**
     * contracts used in functional declarations and object declarations
     * Contract ::= Requires? Ensures? Invariant?
     * Requires ::= requires { ExprList? }
     * Ensures ::= ensures { EnsuresClauseList? }
     * Invariant ::= invariant { ExprList? }
     * CoercionContract ::= Ensures? Invariant?
     * e.g.) requires { n GE 0 } ensures { result GE 0 }
     */
    Contract(Option<List<Expr>> requires = None.<List<Expr>>make(),
             Option<List<EnsuresClause>> ensures =
                 None.<List<EnsuresClause>>make(),
             Option<List<Expr>> invariants = None.<List<Expr>>make());
    /**
     * ensures clause used in contracts
     * EnsuresClause ::= Expr (provided Expr)?
     * e.g.) sorted(result) provided sorted(input)
     */
    EnsuresClause(Expr post, Option<Expr> pre = None.<Expr>make());
    /**
     * modifier
     * TraitMod      ::= AbsTraitMod | private
     * AbsTraitMod   ::= value | test
     * ObjectMods    ::= TraitMods
     * AbsObjectMods ::= AbsTraitMods
     * MdMod         ::= FnMod | override
     * AbsMdMod      ::= AbsFnMod | override
     * FnMod         ::= AbsFnMod | private
     * AbsFnMod      ::= LocalFnMod | test
     * LocalFnMod    ::= atomic | io
     * ParamFldMod   ::= var | hidden | settable | wrapped
     * VarMod        ::= AbsVarMod | private
     * AbsVarMod     ::= var | test
     * FldMod        ::= var | AbsFldMod
     * AbsFldMod     ::= ApiFldMod | wrapped | private
     * ApiFldMod     ::= hidden | settable | test
     */
    abstract Modifier();
        /**
         * e.g.) abstract m(x: ZZ32): ()
         */
        ModifierAbstract();
        /**
         * e.g.) atomic f(x: ZZ32): ()
         */
        ModifierAtomic();
        /**
         * e.g.) getter velocity(): (RR Velocity)^3
         */
        ModifierGetter();
        /**
         * e.g.) hidden x: ZZ32
         */
        ModifierHidden();
        /**
         * e.g.) io print(s: String): ()
         */
        ModifierIO();
        /**
         * e.g.) override m(x: ZZ32): ()
         */
        ModifierOverride();
        /**
         * e.g.) private f(): ()
         */
        ModifierPrivate();
        /**
         * e.g.) settable message: Maybe[\String\]
         */
        ModifierSettable();
        /**
         * e.g.) setter velocity(v: (RR Velocity)^3): ()
         */
        ModifierSetter();
        /**
         * e.g.) test object TestSuite(testFunctions = {}) end
         */
        ModifierTest();
        /**
         * e.g.) object O(transient x: ZZ32) end
         */
        ModifierTransient();
        /**
         * e.g.) value object IntEmpty extends List[\ZZ32\] end
         */
        ModifierValue();
        /**
         * e.g.) var x: ZZ32
         */
        ModifierVar();
        /**
         * e.g.) coerce (x: RR32) widens = ...
         */
        ModifierWidens();
        /**
         * e.g.) wrapped val: Dictionary[\T\]
         */
        ModifierWrapped();
    /**
     * static parameter
     */
    abstract StaticParam();
       /**
         * bool parameter
         * StaticParam ::= bool Id
         * e.g.) bool nan
         */
        BoolParam(Id id);
       /**
         * dimension parameter
         * StaticParam ::= dim Id
         * e.g.) dim D
         */
        DimensionParam(Id id);
       /**
         * int parameter
         * StaticParam ::= int Id
         * e.g.) int i
         */
        IntParam(Id id);
       /**
         * nat parameter
         * StaticParam ::= nat Id
         * e.g.) nat len
         */
        NatParam(Id id);
       /**
         * operator parameter
         * StaticParam ::= opr Op
         * e.g.) opr ODOT
         */
        OperatorParam(Op op);
       /**
         * type parameter
         * StaticParam ::= Id Extends? ( absorbs unit )?
         * e.g.) EltType extends Number absorbs unit
         */
        SimpleTypeParam(Id id,
                        List<TraitType> extendsClause =
                            Collections.<TraitType>emptyList(),
                        boolean absorbs = false);
       /**
         * unit parameter
         * StaticParam ::= unit Id ( : DimRef )? ( absorbs unit )?
         * e.g.) unit U absrbs unit
         */
        UnitParam(Id id, Option<DimRef> dim = None.<DimRef>make(),
                  boolean absorbs = false);
    /**
     * name representing functionals
     */
    abstract FnName();
        /**
         * qualified name
         * DottedId ::= Id(.Id)*
         * e.g.) com.sun.fortress.nodes_util.getName
         */
        DottedId(List<Id> names);
        /**
         * internal name for anonymous function expressions
         * not created during parsing but during evaluation
         * e.g.) name for "fn x => x + 1"
         */
        AnonymousFnName();
        /**
         * internal name for anonymous constructor expressions
         * not created during parsing but during evaluation
         * e.g.) name for "object extends List cons(x) = Cons(x, self) end"
         */
        ConstructorFnName(GenericWithParams def);
        /**
         * name representing operators
         */
        abstract OprName();
            /**
             * qualified operator name
             * internal uses only
             * e.g.) com.sun.fortress.nodes_util.getName
             */
            DottedOpr(List<Id> api, SimpleOprName opr);
            /**
             * unqualified operator name
             */
            abstract SimpleOprName();
                /**
                 * pair of enclosing operators
                 * EncloserPair ::= LeftEncloser RightEncloser
                 * e.g.) </ />
                 */
                Enclosing(Op open, Op close);
                /**
                 * operator that is not an encloser, a postfix operator,
                 * a subscripted assignment, a subscripting operator
                 * e.g.) COMPOSE
                 * e.g.) +
                 */
                Opr(Op op);
                /**
                 * postfix operator
                 * e.g.) 3!
                 */
                PostFix(Op op);
                /**
                 * subscripted assignment operator [ ] :=
                 * e.g.) a[i] := 1
                 */
                SubscriptAssign();
                /**
                 * subscripting operator [ ]
                 * e.g.) a[i]
                 */
                SubscriptOp();
    /**
     * array comprehension clause
     * ArrayComprehensionLeft ::= IdOrInt |-> Expr
     *                          | ( IdOrInt, IdOrIntList ) |-> Expr
     * IdOrInt ::= Id
     *           | IntLiteral
     * ArrayComprehensionClause ::= ArrayComprehensionLeft | GeneratorList
     * e.g.) (x, y) = 0 | x <- {0, 1, 2}, y <- {0, 1, 2}
     */
    ArrayComprehensionClause(List<Expr> bind, Expr init, List<Generator> gens);
    /**
     * binding used in tuple expressions and typecase expressions
     * Binding ::= Id = Expr
     * e.g.) x = myLoser.myField
     */
    Binding(Id id, Expr init);
    /**
     * case clause used in case expressions and extremum expressions
     * CaseClause ::= Expr => BlockElems
     * e.g.) { Jupiter, Saturn, Uranus, Neptune } => "outer"
     */
    CaseClause(Expr match, Block body);
    /**
     * condition expression used in case expressions and extremum expressions
     */
    abstract CaseParam();
        /**
         * condition expression used in case expressions
         */
        CaseParamExpr(Expr expr);
        /**
         * "largest" used in extremum expressions
         */
        CaseParamLargest();
        /**
         * "smallest" used in extremum expressions
         */
        CaseParamSmallest();
    /**
     * catch clause used in try expressions
     * Catch ::= catch Id CatchClauses
     * e.g.) catch e IOException => throw ForbiddenException(e)
     */
    Catch(Id id, List<CatchClause> clauses);
    /**
     * each clause in a catch clause used in try expressions
     * CatchClause ::= TraitType => BlockElems
     * e.g.) IOException => throw ForbiddenException(e)
     */
    CatchClause(TraitType match, Block body);
    /**
     * block expression used in do expressions
     * DoFront ::= (at Expr)? atomic? do BlockElems?
     * e.g.) at a.region(j) do w := a_j
     */
    DoFront(Option<Expr> loc = None.<Expr>make(),
            boolean atomic = false, Block expr);
    /**
     * if clause used in if expressions
     * DelimitedExpr ::= if Expr then BlockElems Elifs? Else? end
     * Elif ::= elif Expr then BlockElems
     * e.g.) if x IN { 0, 1, 2 } then 0
     */
    IfClause(Expr test, Block body);
    /**
     * typecase clause used in typecase expressions
     * TypecaseClause ::= TypecaseTypeRefs => BlockElems
     * TypecaseTypeRefs ::= ( TypeRefList )
     *                    | TypeRef
     * e.g.) String => x.append("foo")
     */
    TypecaseClause(List<TypeRef> match, Block body);
    /**
     * key/value pair used in map expressions and map comprehensions
     * Entry ::= Expr |-> Expr
     * e.g.) 'a' |-> 0
     */
    Entry(Expr key, Expr value);
    /**
     * array and matrix size
     * ExtentRange ::= StaticArg? # StaticArg?
     *               | StaticArg? : StaticArg?
     *               | StaticArg
     * e.g.) 3#5
     */
    ExtentRange(Option<StaticArg> base, Option<StaticArg> size);
    /**
     * generator
     * Generator ::= IdOrIdTuple <- Expr
     *             | Expr
     * IdOrIdTuple ::= Id
     *               | ( Id, IdList )
     * e.g.) (i, j) <- my2DArray.indices
     */
    Generator(List<Id> bind, Expr init);
    /**
     * identifier
     * e.g.) hashCode
     */
    Id(String name);
    /**
     * operator symbol
     * e.g.) ===
     */
    Op(String name);
    /**
     * array indices
     */
    abstract Indices();
        /**
         * array dimensionality
         * ArraySize ::= ExtentRange(, ExtentRange)*
         * e.g.) 3, 2#1, 3:5
         */
        FixedDim(List<ExtentRange> extents);
    /**
     * keyword type used in tuple types
     * KeywordType ::= Id = TypeRef
     * e.g.) x = String
     */
    KeywordType(Id id, TypeRef type);
    /**
     * operator on dimensions and units
     * DUPreOp ::= square | cubic | inverse
     * DUPostOp ::= squared | cubed
     */
    abstract DimUnitOp();
        /**
         * e.g.) second squared
         */
        SquareDimUnit();
        /**
         * e.g.) cubic centimeter
         */
        CubicDimUnit();
        /**
         * e.g.) inverse ohms
         * e.g.) grams per cubic centimeter
         */
        InverseDimUnit();
    /**
     * varargs expression used in tuple expressions
     * Expr...
     * e.g.) [3 4 5]...
     */
    VarargsExpr(Expr varargs);
    /**
     * varargs type used in tuple types and varargs parameters
     * TypeRef ...
     * e.g.) ZZ32...
     */
    VarargsType(TypeRef type);
end;
