(*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component fortress.sparseMatrix

import * from numeric
import * from array
import * from generator

export fortress.sparse

trait Sparse[\T extends {Numeric}, nat m, nat n\]
    extends { MatrixLike[\T,m,n\] }
    mul(v) = do
      r := Array1[\T,n\](0)
      for e,i,j <- elements do
        atomic do r[i] += e v[j] end
      end
      r
    end
end

(* Sparse matrices do not admit efficient indexing in general, but bulk
   operations including enumeration are fast.  The first three
   representations can contain multiple entries per index in the
   creating generator. *)

object Coordinate[\T extends {Numeric}, nat m, nat n\]
    (nonzero: generator3[\T,m,n\],
     distribution: Distribution = defaultDistribution())
    extends { Sparse[\T,m,n\] }
    nonzeros : Int = nonzero.size

    (val : T[1,nonzeros+0], row : Int[1,nonzeros+0], col : Int[1,nonzeros+0]) = do
      v = distribution.Array1()
      r = distribution.Array1()
      c = distribution.Array1()
      entry : Int := 1
      for e,i,j <- nonzero do
        val[entry] := e
        row[entry] := i
        col[entry] := j
        entry := entry + 1
      end
      (v,r,c)
    end
end

value object SparseElement[\T extends {Numeric}\]
    ( pos : Int,
      val : T )
    extends { Ordering, Combine }
  ordering(e:SparseElement[\T\]) = pos.ordering(e.pos)
  combine(e:SparseElement[\T\]) = SparseElement(pos, val + e.val)
end

object SparseRow[\T extends {Numeric}, nat m, nat n\]
    (coord : Coordinate[\T,m,n\],
     distribution : Distribution = rowMajor() )
    extends Sparse[\T,m,n\]
  rows : (SparseElement[\T\][])[m+0] = do
    rowSize : Int[m+0] = distribution.array(0)
    (atomic rowSize[i] += 1),
        (e,i,j) <- coord.elements
    r : (T[])[m+0] = distribution.array([])
    r[i] := distribution.shift(i).transpose.array(s),
        (s,i) <- rowSize.elements
    for e,i,j <- coord.elements do
      atomic do
        j := rowSize[i]
        rowSize[i] -= 1
      end
      r[i][j] := SparseElement(j,e)
    end
    r
  end

(*
  mul(v) =
    [ [i] = SUM[(e,j) <- row.elements] e.val v[e.pos] |
          (row, i) <- rows.indices ]
*)
end

object SparseCol[\T extends {Numeric}, nat m, nat n\]
    (coord : Coordinate[\T,m,n\],
     distribution : Distribution = defaultDistribution() )
    extends { Sparse[\T,m,n\] }
  cols : SparseElement[\T\][n+0][] = do
    nonzeros = coord.nonzeros
    innerdist = distribution.permuteindices(2,1)
(*
    colSize = [ [i] = 0 | i <- (1#n).distribute(innerdist) ]
*)
    for e,i,j <- coord.elements do
      atomic colSize[j] += 1
    end
    c =
    r =
      [ j |-> Array1[\SparseElement[\T\],colSize[j],1\](
                      distribution = distribution) |
            j <- colSize.indices]
    for e,i,j <- coord.elements do
      atomic do
        i' := colSize[j]
        colSize[j] -= 1
      end
      c[j][i'] := SparseElement(i,e)
    end
    c
  end

  mul(v) = do
    r = [ j |-> 0 | j <- 1#n ]
    for c,j <- cols.elements,
        e,i <- c.elements do
      r[e.pos] += e.val v[j]
    end
    r
  end
end

object CompressedSparseRow[\T extends {Numeric}, nat m, nat n\]
    (coord : Coordinate[\T,m,n\],
     distribution : Distribution = defaultDistribution() )
    extends { Sparse[\T,m,n\] }
  sr = do
    sr_ = SparseRow(coord, distribution = distribution)
    for r,i <- sr.rows.elements do
      sr_.rows[i] := r.sortUniq()
    end
    sr_
  end

  mul(v) = sr.mul(v)
end

(* Admits efficient indexing, slow update *)
object CompressedSparseCol[\T extends {Numeric}, nat m, nat n\]
    (coord : Coordinate[\T,m,n\],
     distribution : Distribution = defaultDistribution() )
    extends { Sparse[\T,m,n\] }
  sc = do
    sc_ = SparseCol(coord, distribution = distribution)
    for c,j <- sc.cols.elements do
      sc_.cols[j] := c.sortUniq()
    end
    sc_
  end

  mul(v) = sc.mul(v)
end


end
