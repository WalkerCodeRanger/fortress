(*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component pureList
export Executable

(** Finger trees, based on Ralf Hinze and Ross Paterson's article, JFP
    16:2 2006.

    Why finger trees?  They're balanced and support nearly any
    operation we care to think of in optimal asymptotic time and
    space.  The code is niggly due to lots of cases, but fast in
    practice.

    It's also a trial for encoding type-based invariants in Fortress.
    Can we represent "array of size at most n"?  Not yet, but we ought
    to be able to do so.  This involves questions about the encoding
    of existentials, especially constrained existentials.

  *)

(* We must wrap the FingerTree, since we need also wrap the elements
   in order compute the nested monoidal computation systematically. *)
value object PureList[\ E \](it : FingerTree[\E\]) extends { Generator[\E\] }
  getter size(): ZZ32 = it.size()
  getter empty(): Boolean = it.empty()
  getter left():Maybe[\E\] = it.left()
  getter right():Maybe[\E\] = it.right()
  getter extractLeft(): Maybe[\(E,PureList[\E\])\] = it.extractLeft()
  getter extractRight(): Maybe[\(PureList[\E\],E)\] = it.extractRight()
  generate[\R\](r: Reduction[\R\], body: E->R): R = it.generate[\R\](r,body)
  append(f:PureList[\E\]): PureList[\E\] =
      PureList[\E\](it.append(f.contents()))
  addLeft(e:E):PureList[\E\] =
      PureList[\E\](it.addLeft(e))
  addRight(e:E):PureList[\E\] =
      PureList[\E\](it.addRight(e))
  take(n:ZZ32): PureList[\E\] = PureList[\E\](it.take(n))
  drop(n:ZZ32): PureList[\E\] = PureList[\E\](it.drop(n))
  split(n:ZZ32): (PureList[\E\], PureList[\E\]) = do
      (l,r) = it.split(n)
      (PureList[\E\](l),PureList[\E\](r))
    end
  contents():FingerTree[\E\] = it
  toString():String = it.toString()
end

emptyList[\E\](): PureList[\E\] = PureList[\E\](D0[\E\]())
singleton[\E\](e:E): PureList[\E\] = PureList[\E\](D1[\E\](e))

trait FingerTree[\ E \] extends Generator[\E\]
    comprises { D01[\E\], NonEmptyFingerTree[\E\] }
  getter left():Maybe[\E\]
  getter right():Maybe[\E\]
  getter extractLeft():Maybe[\(E,PureList[\E\])\]
  getter extractRight():Maybe[\(PureList[\E\],E)\]
  append(f:D01[\E\]) : FingerTree[\E\] = addRightD(f)
  append(f:Deep[\E\]) : FingerTree[\E\]
  addLeftD(e:D0[\E\]) : FingerTree[\E\] = self
  addLeftD(e:D14[\E\]) : FingerTree[\E\]
  addLeft(e:E):FingerTree[\E\]
  addRightD(e:D0[\E\]) : FingerTree[\E\] = self
  addRightD(e:D14[\E\]) : FingerTree[\E\]
  addRight(e:E):FingerTree[\E\]
  append3(e:D04[\E\], f:D01[\E\]):FingerTree[\E\] = addRightD(e).addRightD(f)
  append3(e:D04[\E\], f:Deep[\E\]):FingerTree[\E\]
  take(n:ZZ32): FingerTree[\E\] = do (r,_) = split(n); r end
  drop(n:ZZ32): FingerTree[\E\] = do (_,r) = split(n); r end
  split(n:ZZ32): (FingerTree[\E\], FingerTree[\E\])
end

object Concat[\E\]() extends Reduction[\ PureList[\E\] \]
  empty(): PureList[\E\] = PureList[\E\](D0[\E\]())
  join(a:PureList[\E\], b:PureList[\E\]): PureList[\E\] = a.append(b)
end

trait NonEmptyFingerTree[\ E \] extends FingerTree[\E\]
    comprises { D1[\E\], Deep[\E\] }
  getter empty(): Boolean = false
  getter left():Just[\E\]
  getter right():Just[\E\]
  getter extractLeft():Just[\(E,PureList[\E\])\]
  getter extractRight():Just[\(PureList[\E\],E)\]
end

(* The type of all digits, from 0 to 4.
   We populate the sets of digits of particular sizes.  The ones which
   matter most are D14 (fringes of a Deep), D01 (shallow FingerTree), and
   D23 (nodes of the middle of a Deep).  *)
trait D04[\E\] extends Generator[\E\]
    comprises { D03[\E\], D14[\E\] }
  toFinger():FingerTree[\E\]
  take(n:ZZ32):D04[\E\]
  drop(n:ZZ32):D04[\E\]
  split(n:ZZ32):(D04[\E\],D04[\E\]) = (take(n), drop(n))
end

trait D03[\E\] extends D04[\E\]
    comprises { D02[\E\], D13[\E\] }
  cons(e:E) : D14[\E\]
  snoc(e:E) : D14[\E\]
end

trait D14[\E\] extends D04[\E\]
    comprises { D13[\E\], D24[\E\] }
  getter empty(): Boolean = false
  getter uncons() : (E,D03[\E\])
  getter unsnoc() : (D03[\E\],E)
  getter car() : E
  getter rac() : E
  nodes3(x:D04[\E\],y:D14[\E\]):D14[\D23[\E\]\]
  nodes2(x:D14[\E\]):D13[\D23[\E\]\]
end

trait D02[\E\] extends D03[\E\]
    comprises { D01[\E\],D12[\E\] }
  cons(e:E) : D13[\E\]
  snoc(e:E) : D13[\E\]
end

trait D13[\E\] extends { D03[\E\], D14[\E\] }
    comprises { D12[\E\], D23[\E\] }
  getter uncons() : (E,D02[\E\])
  getter unsnoc() : (D02[\E\],E)
  cons(e:E) : D24[\E\]
  snoc(e:E) : D24[\E\]
  nodes3(x:D04[\E\],y:D14[\E\]):D14[\D23[\E\]\]
  nodes2(x:D14[\E\]):D13[\D23[\E\]\]
end

trait D24[\E\] extends D14[\E\]
  getter uncons() : (E,D13[\E\])
  getter unsnoc() : (D13[\E\],E)
  nodes3(x:D04[\E\],y:D14[\E\]):D14[\D23[\E\]\]
  nodes2(x:D14[\E\]):D13[\D23[\E\]\]
  nodes1():D12[\D23[\E\]\]
end

trait D01[\E\] extends { D02[\E\], FingerTree[\E\], SequentialGenerator[\E\] }
    comprises { D0[\E\], D1[\E\] }
  cons(e:E) : D12[\E\]
  snoc(e:E) : D12[\E\]
  append(f:Deep[\E\]) : FingerTree[\E\] = f.addLeftD(self)
  toFinger():FingerTree[\E\] = self
end

trait D12[\E\] extends { D02[\E\], D13[\E\] }
    comprises { D1[\E\], D2[\E\] }
  getter uncons() : (E,D01[\E\])
  getter unsnoc() : (D01[\E\],E)
  cons(e:E) : D34[\E\]
  snoc(e:E) : D34[\E\]
  nodes3(x:D04[\E\],y:D14[\E\]):D14[\D23[\E\]\]
  nodes2(x:D14[\E\]):D12[\D23[\E\]\]
end

trait D23[\E\] extends { D13[\E\], D24[\E\] }
    comprises { D2[\E\], D3[\E\] }
  getter uncons() : (E,D12[\E\])
  getter unsnoc() : (D12[\E\],E)
  cons(e:E) : D34[\E\]
  snoc(e:E) : D34[\E\]
  nodes3(x:D04[\E\],y:D14[\E\]):D14[\D23[\E\]\]
  nodes2(x:D14[\E\]):D13[\D23[\E\]\]
end

trait D34[\E\] extends D24[\E\]
    comprises { D3[\E\], D4[\E\] }
  getter uncons() : (E,D23[\E\])
  getter unsnoc() : (D23[\E\],E)
  nodes3(x:D04[\E\],y:D14[\E\]):D24[\D23[\E\]\]
  nodes2(x:D14[\E\]):D23[\D23[\E\]\]
end

object D0[\E\]() extends { D01[\E\] }
  getter empty():Boolean = true
  getter size():ZZ32 = 0
  getter left():Nothing[\E\] = Nothing[\E\]()
  getter right():Nothing[\E\] = Nothing[\E\]()
  getter extractLeft():Nothing[\(E,PureList[\E\])\] = Nothing[\(E,PureList[\E\])\]()
  getter extractRight():Nothing[\(E,PureList[\E\])\] = Nothing[\(E,PureList[\E\])\]()
  generate[\R\](r: Reduction[\R\], body: E->R): R = r.empty()
  cons(e:E):D1[\E\] = D1[\E\](e)
  snoc(e:E):D1[\E\] = D1[\E\](e)
  append(f:Deep[\E\]):Deep[\E\] = f
  addLeft(e:E):FingerTree[\E\] = cons(e)
  addLeftD(e:D14[\E\]) : FingerTree[\E\] = e.toFinger()
  addRight(e:E):FingerTree[\E\] = snoc(e)
  addRightD(e:D14[\E\]): FingerTree[\E\] = e.toFinger()
  append3(e:D04[\E\], f:Deep[\E\]):FingerTree[\E\] = f.addLeftD(e)
  toString() = "#"
  take(_:ZZ32): D0[\E\] = self
  drop(_:ZZ32): D0[\E\] = self
  split(_:ZZ32): (D0[\E\],D0[\E\]) = (self,self)
end

object D1[\E\](a:E) extends { D01[\E\], D12[\E\], NonEmptyFingerTree[\E\] }
  getter size():ZZ32 = 1
  getter left():Just[\E\] = Just[\E\](a)
  getter right():Just[\E\] = Just[\E\](a)
  getter extractLeft():Just[\(E,PureList[\E\])\] = do
      (h,t) = uncons()
      Just[\(E,PureList[\E\])\](h,PureList[\E\](t))
    end
  getter extractRight():Just[\(E,PureList[\E\])\] = do
      (i,l) = unsnoc()
      Just[\(PureList[\E\],E)\](PureList[\E\](i),l)
    end
  getter uncons():(E,D0[\E\]) = (a,D0[\E\]())
  getter unsnoc():(D0[\E\],E) = (D0[\E\](),a)
  getter car() = a
  getter rac() = a
  generate[\R\](r: Reduction[\R\], body: E->R): R = body(a)
  cons(e:E):D2[\E\] = D2[\E\](e,a)
  snoc(e:E):D2[\E\] = D2[\E\](a,e)
  append(f:FingerTree[\E\]) = f.addLeftD(self)
  addLeft(e:E):FingerTree[\E\] = addLeftD(D1[\E\](e))
  addLeftD(e:D14[\E\]) = Deep[\E\](e.size()+size(),e,D0[\D23[\E\]\](),self)
  addRight(e:E):FingerTree[\E\] = addRightD(D1[\E\](e))
  addRightD(e:D14[\E\]) = Deep[\E\](size()+e.size(),self,D0[\D23[\E\]\](),e)
  append3(e:D04[\E\],f:Deep[\E\]):FingerTree[\E\] = f.addLeftD(e).addLeftD(self)
  nodes3(x:D04[\E\],y:D14[\E\]):D14[\D23[\E\]\] =
    fail("Should never be called, shortcoming of comprises handling.")
  nodes3(x:D4[\E\],y:D14[\E\]):D23[\D23[\E\]\] =
    D2[\E\](x.c,x.d).nodes2(y).cons(D3[\E\](a,x.a,x.b))
  nodes3(x:D03[\E\],y:D14[\E\]):D12[\D23[\E\]\] =
    x.cons(a).nodes2(y)
  nodes2(x:D14[\E\]):D12[\D23[\E\]\] =
    fail("Should never be called, shortcoming of comprises handling.")
  nodes2(x:D4[\E\]):D2[\D23[\E\]\] =
    D2[\D23[\E\]\](D3[\E\](a,x.a,x.b),D2[\E\](x.c,x.d))
  nodes2(x:D13[\E\]):D12[\D23[\E\]\] = x.cons(a).nodes1()
  toString()="(" a ")"
  take(n:ZZ32): D01[\E\] = if n<=0 then D0[\E\]() else self end
  drop(n:ZZ32): D01[\E\] = if n<=0 then self else D0[\E\]() end
  split(n:ZZ32): (D01[\E\],D01[\E\]) = if n<=0 then (D0[\E\](),self)
                                               else (self,D0[\E\]()) end
end

object D2[\E\](a:E, b:E) extends { D12[\E\], D23[\E\] }
  getter size():ZZ32 = 2
  getter car() = a
  getter rac() = b
  getter uncons():(E,D1[\E\]) = (a,D1[\E\](b))
  getter unsnoc():(D1[\E\],E) = (D1[\E\](a),b)
  seq():SequentialGenerator[\E\] = SeqD2Generator[\E\](self)
  generate[\R\](r: Reduction[\R\], body: E->R): R = r.join(body(a),body(b))
  cons(e:E):D3[\E\] = D3[\E\](e,a,b)
  snoc(e:E):D3[\E\] = D3[\E\](a,b,e)
  nodes3(x:D04[\E\],y:D14[\E\]):D14[\D23[\E\]\] =
    fail("Should never be called, shortcoming of comprises handling.")
  nodes3(x:D0[\E\],y:D14[\E\]):D14[\D23[\E\]\] =
    nodes2(y)
  nodes3(x:D1[\E\],y:D14[\E\]):D14[\D23[\E\]\] =
    snoc(x.car()).nodes2(y)
  nodes3(x:D24[\E\],y:D14[\E\]):D14[\D23[\E\]\] = do
      (xh, xt) = x.uncons()
      xt.nodes2(y).cons(D3[\E\](a,b,xh))
    end
  nodes2(x:D14[\E\]):D12[\D23[\E\]\] =
    fail("Should never be called, shortcoming of comprises handling.")
  nodes2(x:D1[\E\]):D1[\D23[\E\]\] =
    D1[\D23[\E\]\](self.snoc(x.car()))
  nodes2(x:D2[\E\]):D2[\D23[\E\]\] =
    D2[\D23[\E\]\](self,x)
  nodes2(x:D34[\E\]):D12[\D23[\E\]\] = do
      (xh, xt) = x.uncons()
      xt.nodes1().cons(D3[\a,b,xh\])
    end
  nodes1():D1[\D23[\E\]\] = D1[\D23[\E\]\](self)
  toFinger()=Deep[\E\](2,D1[\E\](a),D0[\D23[\E\]\](),D1[\E\](b))
  toString()="(" a "," b ")"
  take(n:ZZ32): D02[\E\] =
      case n of
          0 => D0[\E\]()
          1 => D1[\E\](a)
          2 => self
      end
  drop(n:ZZ32): D02[\E\] =
      case n of
          0 => self
          1 => D1[\E\](b)
          2 => D0[\E\]()
      end
end

object SeqD2Generator[\E\](x:D2[\E\]) extends SequentialGenerator[\E\]
  getter size():ZZ32 = 2
  generate[\R\](r: Reduction[\R\], body: E->R): R = do
      ab = body(x.a)
      bb = body(x.b)
      r.join(ab,bb)
    end
end

object D3[\E\](a:E, b:E, c:E) extends { D23[\E\], D34[\E\] }
  getter size():ZZ32 = 3
  getter car() = a
  getter rac() = c
  getter uncons():(E,D2[\E\]) = (a,D2[\E\](b,c))
  getter unsnoc():(D2[\E\],E) = (D2[\E\](a,b),c)
  seq():SequentialGenerator[\E\] = SeqD3Generator[\E\](self)
  generate[\R\](r: Reduction[\R\], body: E->R): R =
    r.join(body(a),r.join(body(b),body(c)))
  cons(e:E):D4[\E\] = D4[\E\](e,a,b,c)
  snoc(e:E):D4[\E\] = D4[\E\](a,b,c,e)
  nodes3(x:D04[\E\],y:D14[\E\]):D24[\D23[\E\]\] =
    x.nodes2(y).cons(self)
  nodes2(x:D14[\E\]):D13[\D23[\E\]\] =
    fail("Should never be called, shortcoming of comprises handling.")
  nodes2(x:D1[\E\]):D23[\D23[\E\]\] =
    D2[\D23[\E\]\](D2[\E\](a,b),D2[\E\](c,x.car()))
  nodes2(x:D24[\E\]):D23[\D23[\E\]\] =
    x.nodes1().cons(self)
  nodes1():D1[\D23[\E\]\] = D1[\D23[\E\]\](self)
  toFinger()=Deep[\E\](3,D2[\E\](a,b),D0[\D23[\E\]\](),D1[\E\](c))
  toString()="(" a "," b "," c ")"
  take(n:ZZ32): D03[\E\] =
      case n of
          0 => D0[\E\]()
          1 => D1[\E\](a)
          2 => D2[\E\](a,b)
          3 => self
      end
  drop(n:ZZ32): D03[\E\] =
      case n of
          0 => self
          1 => D2[\E\](b,c)
          2 => D1[\E\](c)
          3 => D0[\E\]()
      end
end

object SeqD3Generator[\E\](x:D3[\E\]) extends SequentialGenerator[\E\]
  getter size():ZZ32 = 3
  generate[\R\](r: Reduction[\R\], body: E->R): R = do
      ab = body(x.a)
      bb = body(x.b)
      abb = r.join(ab,bb)
      cb = body(x.c)
      r.join(abb,cb)
    end
end

object D4[\E\](a:E, b:E, c:E, d:E) extends { D34[\E\] }
  getter size():ZZ32 = 4
  getter car() = a
  getter rac() = d
  getter uncons():(E,D3[\E\]) = (a,D3[\E\](b,c,d))
  getter unsnoc():(D3[\E\],E) = (D3[\E\](a,b,c),d)
  seq():SequentialGenerator[\E\] = SeqD4Generator[\E\](self)
  generate[\R\](r: Reduction[\R\], body: E->R): R =
    r.join(r.join(body(a),body(b)),r.join(body(c),body(d)))
  nodes3(x:D04[\E\],y:D14[\E\]):D24[\D23[\E\]\] =
    D1[\E\](d).nodes3(x,y).cons(D3[\E\](a,b,c))
  nodes2(x:D14[\E\]):D23[\D23[\E\]\] =
    D1[\E\](d).nodes2(x).cons(D3[\E\](a,b,c))
  nodes1():D2[\D23[\E\]\] = D2[\D23[\E\]\](D2[\E\](a,b),D2[\E\](c,d))
  toFinger()=Deep[\E\](4,D2[\E\](a,b),D0[\D23[\E\]\](),D2[\E\](c,d))
  toString()="(" a "," b "," c "," d ")"
  take(n:ZZ32): D04[\E\] =
      case n of
          0 => D0[\E\]()
          1 => D1[\E\](a)
          2 => D2[\E\](a,b)
          3 => D2[\E\](a,b,c)
          4 => self
      end
  drop(n:ZZ32): D04[\E\] =
      case n of
          0 => self
          1 => D2[\E\](b,c,d)
          2 => D1[\E\](c,d)
          3 => D1[\E\](d)
          4 => D0[\E\]()
      end
end

object SeqD4Generator[\E\](x:D4[\E\]) extends SequentialGenerator[\E\]
  getter size():ZZ32 = 4
  generate[\R\](r: Reduction[\R\], body: E->R): R = do
      ab = body(x.a)
      bb = body(x.b)
      abb = r.join(ab,bb)
      cb = body(x.c)
      abc = r.join(abb,cb)
      db = body(x.d)
      r.join(abc,db)
    end
end

object Deep[\E\](sz:ZZ32, l:D14[\E\], m:FingerTree[\ D23[\E\] \], r:D14[\E\])
    extends { NonEmptyFingerTree[\E\] }
  getter size():ZZ32 = sz
  getter left():Just[\E\] = Just[\E\](l.car())
  getter right():Just[\E\] = Just[\E\](r.rac())
  getter extractLeft():Just[\(E,PureList[\E\])\] = do
      (h,t) = extractLeft1(l,m)
      Just[\(E,PureList[\E\])\](h,PureList[\E\](t))
    end
  getter extractRight():Just[\(E,PureList[\E\])\] = do
      (i,lst) = extractRight1(r,m)
      Just[\(PureList[\E\],E)\](PureList[\E\](i),lst)
    end
  seq():SequentialGenerator[\E\] = SeqDeepGenerator[\E\](self)
  generate[\R\](j: Reduction[\R\], body: E->R): R = do
      j.join(
       l.generate[\R\](j,body),
       j.join(m.generate[\R\](j,fn (n23:D23[\E\]):R => n23.generate[\R\](j,body)),
              r.generate[\R\](j,body)))
    end
  addLeft(e:E):FingerTree[\E\] = addLeft1(e,l)
  addLeft1(e:E,l0:D4[\E\]) =
        Deep[\E\](1+sz,D2[\E\](e,l0.a),m.addLeft(D3[\E\](l0.b,l0.c,l0.d)),r)
  addLeft1(e:E,l0:D03[\E\]) = Deep[\E\](1+sz,l0.cons(e),m,r)
  addLeftD(e:D14[\E\]) : FingerTree[\E\] = do
      (ef,er) = e.unsnoc()
      addLeft(er).addLeftD(ef)
    end
  addRight(e:E):FingerTree[\E\] = addRight1(e,r)
  addRight1(e:E,r0:D4[\E\]) =
      Deep[\E\](sz+1,l,m.addRight(D3[\E\](r0.a,r0.b,r0.c)),D2[\E\](r0.d,e))
  addRight1(e:E,r0:D03[\E\]) = Deep[\E\](sz+1,l,m,r.snoc(e))
  addRightD(e:D14[\E\]) : FingerTree[\E\] = do
      (ef,er) = e.uncons()
      addRight(ef).addRightD(er)
    end

  (* Helper methods for extractLeft and extractRight *)
  extractLeft1(l0:D1[\E\], m0:D0[\D23[\E\]\]) = (l0.car(),r.toFinger())
  extractLeft1(l0:D1[\E\], m0:D1[\D23[\E\]\]) = do
      (l1,m1) = m0.uncons()
      (l0.car(),Deep[\E\](sz-1,l1,m1,r))
    end
  extractLeft1(l0:D1[\E\], m0:Deep[\D23[\E\]\]) = do
      (l1,m1) = m0.extractLeft1(m0.l,m0.m)
      (l0.car(),Deep[\E\](sz-1,l1,m1,r))
    end
  extractLeft1(l0:D24[\E\], m0:FingerTree[\D23[\E\]\]) = do
      (f,l1) = l0.uncons()
      (f,Deep[\E\](sz-1,l1,m0,r))
    end
  extractRight1(r0:D1[\E\], m0:D0[\D23[\E\]\]) = (l.toFinger(),r0.rac())
  extractRight1(r0:D1[\E\], m0:D1[\D23[\E\]\]) = do
      (m1,r1) = m0.unsnoc()
      (Deep[\E\](sz-1,l,m1,r1),r0.rac())
    end
  extractRight1(r0:D1[\E\], m0:Deep[\D23[\E\]\]) = do
      (m1,r1) = m0.extractRight1(m0.r,m0.m)
      (Deep[\E\](sz-1,l,m1,r1),r0.rac())
    end
  extractRight1(r0:D24[\E\], m0:FingerTree[\D23[\E\]\]) = do
      (r1,b) = r0.unsnoc()
      (Deep[\E\](sz-1,l,m0,r1),b)
    end

  append(f:Deep[\E\]) : FingerTree[\E\] =
    Deep[\E\](sz+f.size(),l,m.append3(r.nodes2(f.l),f.m),f.r)
  append3(e:D04[\E\], f:Deep[\E\]):FingerTree[\E\] =
    Deep[\E\](sz+e.size()+f.size(),l,m.append3(r.nodes3(e,f.l),f.m),f.r)

  toString() = "[" l.toString() ";" m.toString() ";" r.toString() "]"

  split(n:ZZ32): (FingerTree[\E\], FingerTree[\E\]) = fail("Deep.split: NYI")
end

object SeqDeepGenerator[\E\](x:Deep[\E\]) extends SequentialGenerator[\E\]
  getter size(): ZZ32 = x.size()
  generate[\R\](j: Reduction[\R\], body: E->R): R = do
      gl = x.l.seq().generate[\R\](j,body)
      ml = x.m.seq().generate[\R\](j,fn (n23:D23[\E\]):R => n23.seq().generate[\R\](j,body))
      ll = j.join(gl,ml)
      rl = x.r.seq().generate[\R\](j,body)
      j.join(ll,rl)
    end
end

test_toString(x:Any,y:String):() = do
  assert(x.toString(),y," toString() test")
end

test_strEq(x:Any,y:Any,s:String):() = do
  assert(x.toString(),y.toString(),s)
end

mkContig(r:Range[\ZZ32\]): PureList[\ZZ32\] =
  r.generate[\PureList[\ZZ32\]\](Concat[\ZZ32\](), singleton[\ZZ32\])

chkPop(l:PureList[\ZZ32\],sz:ZZ32): () = do
  n : ZZ32 := 0
  lstr = l.toString()
  println(lstr)
  for e <- seq(l) do
      assert(e,n,"Element wrong in " lstr)
      n+=1
  end
end

chkExtract(l:PureList[\ZZ32\],sz:ZZ32): () = do
  ll : PureList[\ZZ32\] := l
  for i <- seq(0#sz) do
      (e,ll0) = ll.extractLeft().unJust()
      assert(e,i,"extractLeft wrong in " ll)
      ll := ll0
  end
  assert(ll.empty()," not empty after extractLeft(); it's " ll)
  ll := l
  for i <- seq(1#sz) do
      (ll0,e) = ll.extractRight().unJust()
      assert(e,sz-i,"extractRight wrong in " ll)
      ll := ll0
  end
  assert(ll.empty()," not empty after extractRight(); it's " ll)
end

run(args:String...):() = do
  e = D0[\ZZ32\]()
  test_toString(e,"#")
  d1 = D1[\ZZ32\](1)
  test_toString(d1,"(1)")
  d2 = D2[\ZZ32\](2,3)
  test_toString(d2,"(2,3)")
  d3 = D3[\ZZ32\](4,5,6)
  test_toString(d3,"(4,5,6)")
  d4 = D4[\ZZ32\](7,8,9,10)
  test_toString(d4,"(7,8,9,10)")
  test_strEq(e,e.toFinger()," toFinger 0")
  test_strEq(d1,d1.toFinger()," toFinger 1")
  test_strEq(d1,e.addLeftD(d1),"e.addLeftD(d1)")
  test_strEq(d1,e.addRightD(d1),"e.addRightD(d1)")
  test_strEq(d1,d1.addLeftD(e),"d1.addLeftD(e)")
  test_strEq(d1,d1.addRightD(e),"d1.addRightD(e)")
  println("The adventure begins")
  testLens : ZZ32[20] = [ 0 1 2 3 4 5 6 7 8 9 10 15 20 25 35 50 75 100 150 200 ]
  for (_,i) <- seq(testLens) do
      print("\n" i ":")
      li = mkContig(0#i)
      chkPop(li,i)
      chkExtract(li,i)
      for (_,j) <- seq(testLens) do
          print(" " j)
          lj = mkContig(i#j)
          chkPop(li.append(lj),i+j)
      end
  end
  println("")
  println("Succeeded")
end

end
