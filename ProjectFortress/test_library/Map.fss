(*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component Map
export Map

weight:ZZ32 = 3

trait TreeMap[\Key,Val\] comprises {NodeMap[\Key,Val\], EmptyMap[\Key,Val\]}
  size():ZZ32
  isEmpty():Boolean
  getPair():(Key, Val)
  getKey():Key
  getVal():Val
  getLeftChild():TreeMap[\Key,Val\]
  getRightChild():TreeMap[\Key,Val\]
  printTree():()
  toString():String
  member(x:Key): Maybe[\Val\]
  deleteMinimum():TreeMap[\Key,Val\] = do
    (_, res) = self.removeMinimum()
    res
  end
  removeMinimum():((Key,Val), TreeMap[\Key,Val\])
  add(k:Key, v:Val):TreeMap[\Key,Val\]
  update(k:Key, v:Val):TreeMap[\Key,Val\]
  delete(k:Key):TreeMap[\Key,Val\]
  balancedDelete(r:TreeMap[\Key,Val\]):TreeMap[\Key,Val\]
  balancedAdd(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\]
end

object EmptyMap[\Key,Val\]() extends TreeMap[\Key,Val\]
  size():ZZ32 = 0
  isEmpty():Boolean = true
  getPair():(Key, Val) = getPair()
  getKey():Key = getKey()
  getVal():Val = getVal()
  getLeftChild():TreeMap[\Key,Val\] = self
  getRightChild():TreeMap[\Key,Val\] = self
  printTree():() = print "EmptyMap"
  toString():String = "{}"
  member(x:Key): Maybe[\Val\] = Nothing[\Val\]()
  removeMinimum():((Key,Val), TreeMap[\Key,Val\]) = removeMinimum()
  add(k:Key, v:Val):TreeMap[\Key,Val\] = NodeMap[\Key,Val\]((k,v), self, self)
  update(k:Key, v:Val):TreeMap[\Key,Val\] = add(k, v)
  delete(k:Key):TreeMap[\Key,Val\] = self
  balancedDelete(r:TreeMap[\Key,Val\]):TreeMap[\Key,Val\] = r
  balancedAdd(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](x,self,self)
end

object NodeMap[\Key,Val\](pair:(Key,Val), left:TreeMap[\Key,Val\],
                          right:TreeMap[\Key,Val\]) extends TreeMap[\Key,Val\]
  sz:ZZ32 = 1 + left.size() + right.size()
  (key, val) = tuple(pair)

  tuple(k:Key,v:Val):(Key,Val) = (k,v)
  size():ZZ32 = sz
  isEmpty():Boolean = false
  getPair():(Key, Val) = pair
  getKey():Key = key
  getVal():Val = val
  getLeftChild():TreeMap[\Key,Val\] = left
  getRightChild():TreeMap[\Key,Val\] = right

  printTree():() = do
    print("((")
    print(key)
    print(",")
    print(val)
    print(") ")
    left.printTree()
    right.printTree()
    println(")")
  end

  toString():String = do
    temp:TreeMap[\Key,Val\] := self
    res:String := "{"
    (two, delmin) = temp.removeMinimum()
    (k, v) = two
    res DOT= k "|->" v
    temp := delmin
    while (NOT temp.isEmpty()) do
      (twoo, delminn) = temp.removeMinimum()
      (kk,vv) = twoo
      res DOT= ", " kk "|->" vv
      temp := delminn
    end
    res "}"
  end

  member(x:Key): Maybe[\Val\] =
    if   x = key then Just[\Val\](val)
    elif x < key then left.member(x)
    else right.member(x)
    end

  removeMinimum() =
    if left.isEmpty() then (pair,right)
    else
      (min, delmin) = left.removeMinimum()
      (min, balancedAdd(pair,delmin,right))
    end

  add(k:Key, v:Val):TreeMap[\Key,Val\] =
    if   k = key then self
    elif k < key then balancedAdd(pair,left.add(k,v),right)
    else balancedAdd(pair,left,right.add(k,v))
    end

  update(k:Key, v:Val):TreeMap[\Key,Val\] =
    if   k = key then NodeMap[\Key,Val\]((k,v), left, right)
    elif k < key then NodeMap[\Key,Val\](pair, left.update(k,v), right)
    else NodeMap[\Key,Val\](pair, left, right.update(k,v))
    end

  delete(k:Key):TreeMap[\Key,Val\] =
    if   k < key then balancedAdd(pair,left.delete(k),right)
    elif key < k then balancedAdd(pair,left,right.delete(k))
    else              left.balancedDelete(right)
    end

  balancedDelete(r:NodeMap[\Key,Val\]):TreeMap[\Key,Val\] = do
    (min_elt, del_min) = r.removeMinimum()
    balancedAdd(min_elt, self, del_min)
  end
  balancedDelete(r:TreeMap[\Key,Val\]):TreeMap[\Key,Val\] = self

  balancedAdd(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] = do
    ln = left.size()
    rn = right.size()
    if ln + rn < weight then NodeMap[\Key,Val\](x, left, right)
    elif rn > weight ln then
      r = right.getRightChild()
      rl = r.getLeftChild()
      rr = r.getRightChild()
      rln = rl.size()
      rrn = rr.size()
      if rln < rrn
      then single_L(x, left, right)
      else double_L(x, left, right)
      end
    elif ln > weight rn then
      l = left.getLeftChild()
      ll = l.getLeftChild()
      lr = l.getRightChild()
      lln = ll.size()
      lrn = lr.size()
      if lrn < lln
      then single_R(x, left, right)
      else double_R(x, left, right)
      end
    else NodeMap[\Key,Val\](x, left, right) end
  end

  single_L(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](right.getPair(),
                       NodeMap[\Key,Val\](x, left, right.getLeftChild()),
                       right.getRightChild())

  single_R(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](left.getPair(),
                       left.getLeftChild(),
                       NodeMap[\Key,Val\](x,left.getRightChild(),right))

  double_L(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](right.getLeftChild().getPair(),
                       NodeMap[\Key,Val\](x, left,
                                          right.getLeftChild().getLeftChild()),
                       NodeMap[\Key,Val\](right.getPair(),
                                          right.getLeftChild().getRightChild(),
                                          right.getRightChild()))

  double_R(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](left.getRightChild().getPair(),
                       NodeMap[\Key,Val\](left.getPair(),
                                          left.getLeftChild(),
                                          left.getRightChild().getLeftChild()),
                       NodeMap[\Key,Val\](x,left.getRightChild().getRightChild(),
                                          right))
end

end
