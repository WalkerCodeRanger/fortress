(*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component Map
export Map

weight:ZZ32 = 4

trait TreeMap[\Key,Val\] extends Generator[\(Key,Val)\]
    comprises {NodeMap[\Key,Val\], EmptyMap[\Key,Val\]}
  seqgen[\R\](r: Reduction[\R\], body: (Key,Val)->R): R
  seq(): SequentialGenerator[\(Key,Val)\] = SeqMapGenerator[\Key,Val\](self)
  getPair():(Key, Val)
  getKey():Key
  getVal():Val
  getLeftChild():TreeMap[\Key,Val\]
  getRightChild():TreeMap[\Key,Val\]
  printTree():()
  toString():String
  member(x:Key): Maybe[\Val\]
  deleteMinimum():TreeMap[\Key,Val\] = do
    (_, res) = self.removeMinimum()
    res
  end
  removeMinimum():((Key,Val), TreeMap[\Key,Val\])
  add(k:Key, v:Val):TreeMap[\Key,Val\]
  update(k:Key, v:Val):TreeMap[\Key,Val\]
  delete(k:Key):TreeMap[\Key,Val\]
  updateWith(f:Maybe[\Val\]->Maybe[\Val\], k:Key): TreeMap[\Key,Val\]
(*
  union(other: TreeMap[\Key,Val\]): TreeMap[\Key,Val\]
  union(f:(Key,Val,Val)->Val, other: TreeMap[\Key,Val\]): TreeMap[\Key,Val\]
*)
  balancedDelete(r:TreeMap[\Key,Val\]):TreeMap[\Key,Val\]
  balancedAdd(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\]
end

singleton[\Key,Val\](k:Key, v:Val): TreeMap[\Key,Val\] = do
    kv = (k,v)
    e = EmptyMap[\Key,Val\]()
    NodeMap[\Key,Val\](kv,e,e)
  end

mapping[\Key,Val\](g: Generator[\(Key,Val)\]): TreeMap[\Key,Val\] = do
    res : TreeMap[\Key,Val\] := EmptyMap[\Key,Val\]()
    for (k,v) <- seq(g) do
       res := res.add(k,v)
    end
    res
  end

object SeqMapGenerator[\Key,Val\](o:TreeMap[\Key,Val\])
    extends SequentialGenerator[\(Key,Val)\]
  generate[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = o.seqgen[\R\](r,body)
end

(*
object MapUnion[\Key,Val\]() extends Reduction[\TreeMap[\Key,Val\]\]
    e = EmptyMap[\Key,Val\]()
    empty():TreeMap[\Key,Val\] = e
    join(a:TreeMap[\Key,Val\], b:TreeMap[\Key,Val\]): TreeMap[\Key,Val\] =
        a.union(b)
end
*)

object EmptyMap[\Key,Val\]() extends TreeMap[\Key,Val\]
  getter size():ZZ32 = 0
  getter isEmpty():Boolean = true
  generate[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = r.empty()
  seqgen[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = r.empty()
  getPair():(Key, Val) = getPair()
  getKey():Key = getKey()
  getVal():Val = getVal()
  getLeftChild():TreeMap[\Key,Val\] = self
  getRightChild():TreeMap[\Key,Val\] = self
  printTree():() = print "EmptyMap"
  toString():String = "{}"
  member(x:Key): Maybe[\Val\] = Nothing[\Val\]()
  removeMinimum():((Key,Val), TreeMap[\Key,Val\]) = removeMinimum()
  add(k:Key, v:Val):TreeMap[\Key,Val\] = NodeMap[\Key,Val\]((k,v), self, self)
  update(k:Key, v:Val):TreeMap[\Key,Val\] = add(k, v)
  delete(k:Key):TreeMap[\Key,Val\] = self
  updateWith(f:Maybe[\Val\]->Maybe[\Val\], k:Key): TreeMap[\Key,Val\] =
      f(Nothing[\Val\]()).maybe[\TreeMap[\Key,Val\]\](
        fn (): EmptyMap[\Key,Val\] => self,
        fn (v:Val): TreeMap[\Key,Val\] => add(k,v))
  union(other: TreeMap[\Key,Val\]): TreeMap[\Key,Val\] = other
  union(f:(Key,Val,Val)->Val, other: TreeMap[\Key,Val\]): TreeMap[\Key,Val\] =
      other

  balancedDelete(r:TreeMap[\Key,Val\]):TreeMap[\Key,Val\] = r
  balancedAdd(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):
      NodeMap[\Key,Val\] = NodeMap[\Key,Val\](x,self,self)
end

object NodeMap[\Key,Val\](pair:(Key,Val), left:TreeMap[\Key,Val\],
                          right:TreeMap[\Key,Val\]) extends TreeMap[\Key,Val\]
  sz:ZZ32 = 1 + left.size() + right.size()
  (key, val) = pair
  getter size():ZZ32 = sz
  getter isEmpty():Boolean = false

  generate[\R\](r: Reduction[\R\], body: (Key,Val)->R): R =
    r.join(r.join(left.generate[\R\](r,body),body(key,val)),
           right.generate[\R\](r,body))
  seqgen[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = do
      ll = left.generate[\R\](r,body)
      mm = body(key,val)
      lm = r.join(ll,mm)
      rr = right.generate[\R\](r,body)
      r.join(lm,rr)
    end

  getPair():(Key, Val) = pair
  getKey():Key = key
  getVal():Val = val
  getLeftChild():TreeMap[\Key,Val\] = left
  getRightChild():TreeMap[\Key,Val\] = right

  printTree():() = do
    print("((")
    print(key)
    print(",")
    print(val)
    print(") ")
    left.printTree()
    right.printTree()
    println(")")
  end

  toString():String = do
    temp:TreeMap[\Key,Val\] := self
    res:String := "{"
    (two, delmin) = temp.removeMinimum()
    (k, v) = two
    res DOT= k "|->" v
    temp := delmin
    while (NOT temp.isEmpty()) do
      (twoo, delminn) = temp.removeMinimum()
      (kk,vv) = twoo
      res DOT= ", " kk "|->" vv
      temp := delminn
    end
    res "}"
  end

  member(x:Key): Maybe[\Val\] =
    if   x = key then Just[\Val\](val)
    elif x < key then left.member(x)
    else right.member(x)
    end

  removeMinimum() =
    if left.isEmpty() then (pair,right)
    else
      (min, delmin) = left.removeMinimum()
      (min, balancedAdd(pair,delmin,right))
    end

  add(k:Key, v:Val):TreeMap[\Key,Val\] =
    if   k = key then self
    elif k < key then balancedAdd(pair,left.add(k,v),right)
    else balancedAdd(pair,left,right.add(k,v))
    end

  update(k:Key, v:Val):TreeMap[\Key,Val\] =
    if   k = key then NodeMap[\Key,Val\]((k,v), left, right)
    elif k < key then NodeMap[\Key,Val\](pair, left.update(k,v), right)
    else NodeMap[\Key,Val\](pair, left, right.update(k,v))
    end

  delete(k:Key):TreeMap[\Key,Val\] =
    if   k < key then balancedAdd(pair,left.delete(k),right)
    elif key < k then balancedAdd(pair,left,right.delete(k))
    else              left.balancedDelete(right)
    end

  updateWith(f:Maybe[\Val\]->Maybe[\Val\], k:Key): TreeMap[\Key,Val\] =
    if   k < key then balancedAdd(pair, left.updateWith(f,k), right)
    elif key < k then balancedAdd(pair, left, right.updateWith(f,k))
    else f(val).maybe[\TreeMap[\Key,Val\]\](
                fn (): TreeMap[\Key,Val\] => left.balancedDelete(right),
                fn (v': Val): TreeMap[\Key,Val\] =>
                    NodeMap[\Key,Val\]((k,v'), left, right))
    end

  union(other: TreeMap[\Key,Val\]): TreeMap[\Key,Val\] =
      union(fn (k:Key, v1:Val, v2:Val) => v1, other)
  union(f:(Key,Val,Val)->Val, other: TreeMap[\Key,Val\]): TreeMap[\Key,Val\] = do
      res : TreeMap[\Key,Val\] := other
      for (k,v) <- seq(self) do
        upd(_: Nothing[\Val\]): Just[\Val\] = Just[\Val\](v)
        upd(j: Just[\Val\]): Just[\Val\] = Just[\Val\](f(k,v,j.unJust()))
        res := res.updateWith(upd,k)
      end
      res
    end

  balancedDelete(r:NodeMap[\Key,Val\]):TreeMap[\Key,Val\] = do
    (min_elt, del_min) = r.removeMinimum()
    balancedAdd(min_elt, self, del_min)
  end
  balancedDelete(r:TreeMap[\Key,Val\]):TreeMap[\Key,Val\] = self

  balancedAdd(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] = do
    ln = left.size()
    rn = right.size()
    if ln + rn < weight then NodeMap[\Key,Val\](x, left, right)
    elif rn > weight ln then
      r = right.getRightChild()
      rl = r.getLeftChild()
      rr = r.getRightChild()
      rln = rl.size()
      rrn = rr.size()
      if rln < rrn
      then single_L(x, left, right)
      else double_L(x, left, right)
      end
    elif ln > weight rn then
      l = left.getLeftChild()
      ll = l.getLeftChild()
      lr = l.getRightChild()
      lln = ll.size()
      lrn = lr.size()
      if lrn < lln
      then single_R(x, left, right)
      else double_R(x, left, right)
      end
    else NodeMap[\Key,Val\](x, left, right) end
  end

  single_L(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](right.getPair(),
                       NodeMap[\Key,Val\](x, left, right.getLeftChild()),
                       right.getRightChild())

  single_R(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](left.getPair(),
                       left.getLeftChild(),
                       NodeMap[\Key,Val\](x,left.getRightChild(),right))

  double_L(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](right.getLeftChild().getPair(),
                       NodeMap[\Key,Val\](x, left,
                                          right.getLeftChild().getLeftChild()),
                       NodeMap[\Key,Val\](right.getPair(),
                                          right.getLeftChild().getRightChild(),
                                          right.getRightChild()))

  double_R(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](left.getRightChild().getPair(),
                       NodeMap[\Key,Val\](left.getPair(),
                                          left.getLeftChild(),
                                          left.getRightChild().getLeftChild()),
                       NodeMap[\Key,Val\](x,left.getRightChild().getRightChild(),
                                          right))
end

end
