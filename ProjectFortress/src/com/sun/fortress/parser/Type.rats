/*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress types.
 */
module Type(Header, Literal, Identifier, Keyword, Symbol, Spacing);

import Header;
import Literal;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* IsType ::= : w Type */
Type IsType = colon w Type ;

/* NonArrowType, TraitType, and DimType are mutually left recursive.
   We've inlined them into each other and removed the left recursion. */
/* Type ::=
     ( w Type w )
   | ArrowType
   | NonArrowType

   ArrowType ::= NonArrowType w -> w NonArrowType (w Throws)?

   NonArrowType ::=
     TraitType
   | TupleType
   | ( w )
   | DimType

   TraitType ::=
     DottedId (w [\ w StaticArgList w \])?
   | Type w [ (w ArraySize)? w ]
   | Type ^ StaticArgFront
   | Type ^ ( w ExtentRange (w x w ExtentRange)* w )

   DimType ::=
     DimRef
   | Type sr DimRef
   | Type w . w DimRef
   | Type w / w DimRef
   | Type w per w DimRef
   | Type sr UnitRef
   | Type w . w UnitRef
   | Type w / w UnitRef
   | Type w per w UnitRef
   | Type w in w DimRef
 */
constant transient Type Type =
     seed:TypeFront list:TypeTail*
     { yyValue = (Type)apply(list, seed); };

private Type TypeFront =
     openparen w a1:Type w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); }
   / a1:TypeFrontNonArrow w rightarrow w a2:NonArrowType a3:(w Throws)?
     { Option<List<TraitType>> throws_;
       if (a3 == null) throws_ = None.<List<TraitType>>make();
       else            throws_ = Some.<List<TraitType>>make(a3);
       yyValue = NodeFactory.makeArrowType(createSpan(yyStart,yyCount), a1, a2,
                                           throws_);
     }
   / TypeFrontNonArrow ;

private NonArrowType TypeFrontNonArrow =
     a1:DottedId a2:(w opendoublesquare w StaticArgList w closedoublesquare)?
     { if (a2 == null) yyValue = new IdType(createSpan(yyStart,yyCount), a1);
       else yyValue = new InstantiatedType(createSpan(yyStart,yyCount), a1, a2);
     }
   / TupleType
   / openparen w closeparen
     { yyValue = new VoidType(createSpan(yyStart,yyCount)); };

private constant transient Action<Type> TypeTail =
     w opensquare a1:(w ArraySize)? w closesquare a2:ArrowTypeTail?
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               Option<FixedDim> indices;
               if (a1 == null) indices = None.<FixedDim>make();
               else            indices = Some.<FixedDim>make(a1);
               NonArrowType ty =
                   NodeFactory.makeArrayType(createSpan(yyStart,yyCount),
                                             (Type)base, indices);
               if (a2 == null) return ty;
               else return NodeFactory.makeArrowType(createSpan(yyStart,yyCount),
                                                     ty, a2.getRange(),
                                                     a2.getThrows());
           }};
     }
   / caret a1:StaticArgFront a2:ArrowTypeTail?
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               ExtentRange er = new ExtentRange(None.<StaticArg>make(),
                                                Some.<StaticArg>make(a1));
               NonArrowType ty =
                   NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),
                                              (Type)base, er);
               if (a2 == null) return ty;
               else return NodeFactory.makeArrowType(createSpan(yyStart,yyCount),
                                                     ty, a2.getRange(),
                                                     a2.getThrows());
           }};
     }
   / caret openparen w a1:ExtentRange a2s:(w cross w ExtentRange)* w closeparen
     a3:ArrowTypeTail?
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               NonArrowType ty =
                   NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),
                                              (Type)base,a1,a2s.list());

               if (a3 == null) return ty;
               else return NodeFactory.makeArrowType(createSpan(yyStart,yyCount),
                                                     ty, a3.getRange(),
                                                     a3.getThrows());
           }};
     };

private ArrowTypeTail ArrowTypeTail =
     w rightarrow w a1:NonArrowType a2:(w Throws)?
     { Option<List<TraitType>> throws_;
       if (a2 == null) throws_ = None.<List<TraitType>>make();
       else            throws_ = Some.<List<TraitType>>make(a2);
       yyValue = new ArrowTypeTail(a1, throws_);
     };

/* ArrowType ::= NonArrowType w -> w NonArrowType (w Throws)? */
ArrowType ArrowType =
     a1:NonArrowType w rightarrow w a2:NonArrowType a3:(w Throws)?
     { Option<List<TraitType>> throws_;
       if (a3 == null) throws_ = None.<List<TraitType>>make();
       else            throws_ = Some.<List<TraitType>>make(a3);
       yyValue = NodeFactory.makeArrowType(createSpan(yyStart,yyCount),
                                           a1, a2, throws_);
     };

private NonArrowType NonArrowType =
     TraitType
   / TupleType
   / openparen w closeparen
     { yyValue = new VoidType(createSpan(yyStart,yyCount)); }
/* ************************************************
 * Not Yet Implemented ***************************
   / DimType
************************************************ */
   ;

/* TraitType ::=
     DottedId (w [\ w StaticArgList w \])?
   | Type [ (w ArraySize)? w ]
   | Type ^ StaticArgFront
   | Type ^ ( w ExtentRange (w x w ExtentRange)* w )
 */
TraitType TraitType =
     a1:DottedId a2:(w opendoublesquare w StaticArgList w closedoublesquare)?
     { if (a2 == null) yyValue = new IdType(createSpan(yyStart,yyCount), a1);
       else yyValue = new InstantiatedType(createSpan(yyStart,yyCount), a1, a2);
     }
   / a1:Type w opensquare a2:(w ArraySize)? w closesquare
     { Option<FixedDim> indices;
       if (a2 == null) indices = None.<FixedDim>make();
       else            indices = Some.<FixedDim>make(a2);
       yyValue = NodeFactory.makeArrayType(createSpan(yyStart,yyCount), a1,
                                           indices);
     }
   / a1:Type caret a2:StaticArgFront
     { ExtentRange er = new ExtentRange(None.<StaticArg>make(),
                                        Some.<StaticArg>make(a2));
       yyValue = NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),a1,er);
     }
   / a1:Type caret openparen w a2:ExtentRange a3s:(w cross w ExtentRange)* w
     closeparen
     { yyValue = NodeFactory.makeMatrixType(createSpan(yyStart,yyCount), a1, a2,
                                            a3s.list());
     };

/* ************************************************
 * Not Yet Implemented ***************************
private constant inline Action<Type> ProductDimType =
     sr a1:DimRef
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               return new ProductDimType(createSpan(yyStart,yyCount),
                                         (Type)base, a1);
           }};
     }
   / w "DOT":op w a1:DimRef
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               return new ProductDimType(createSpan(yyStart,yyCount),
                                         (Type)base, a1);
           }};
     };

private constant inline Action<Type> QuotientDimType =
     w "slash":op w a1:DimRef
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               return new QuotientDimType(createSpan(yyStart,yyCount),
                                          (Type)base, a1);
           }};
     }
   / w "per":op w a1:DimRef
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               return new QuotientDimType(createSpan(yyStart,yyCount),
                                          (Type)base, a1);
           }};
     };

private constant inline Action<Type> ProductUnitType =
     sr a1:UnitRef
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               return new ProductUnitType(createSpan(yyStart,yyCount),
                                          (Type)base, a1);
           }};
     }
   / w "DOT":op w a1:UnitRef
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               return new ProductUnitType(createSpan(yyStart,yyCount),
                                          (Type)base, a1);
           }};
     };

private constant inline Action<Type> QuotientUnitType =
     w "slash":op w a1:UnitRef
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               return new QuotientUnitType(createSpan(yyStart,yyCount),
                                           (Type)base, a1);
           }};
     }
   / w "per":op w a1:UnitRef
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               return new QuotientUnitType(createSpan(yyStart,yyCount),
                                           (Type)base, a1);
           }};
     };
************************************************ */

private constant inline Action<Type> DimTypeConversion =
     w "in":op w a1:DimRef
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               return new DimTypeConversion(createSpan(yyStart,yyCount),
                                            (Type)base, a1);
           }};
     };

/* TupleType ::=
     ( w (Type w , w)* (Type w ... w , w)? KeywordType (w , w KeywordType)* w )
   | ( w (Type w , w)* Type w ... w )
   | SimpleTupleType
 */
Type TupleType =
     openparen w a1s:(Type w comma w)* a2:(Type w ellipses w comma w)?
       a3:KeywordType a4s:(w comma w KeywordType)* w closeparen
     { List<Type>   ts1 = a1s.list();
       Option<VarargsType> ts2 = ((a2 != null)?
                                   Some.<VarargsType>make(new VarargsType(createSpan(yyStart,yyCount), a2)) :
                                   None.<VarargsType>make());
       List<KeywordType> ts3 = a4s.list();
       ts3.add(0, a3);
       yyValue = new TupleType(createSpan(yyStart,yyCount), ts1, ts2, ts3);
     }
   / openparen w a1s:(Type w comma w)* a2:Type w ellipses w closeparen
     { List<Type> ts1 = FortressUtil.mkList(a1s.list());
       Option<VarargsType> ts2 = Some.<VarargsType>make(new VarargsType(createSpan(yyStart,yyCount), a2));
       yyValue = NodeFactory.makeTupleType(createSpan(yyStart,yyCount), ts1, ts2);
     }
   / SimpleTupleType ;

/* KeywordType ::= Id w = w Type */
private KeywordType KeywordType = a1:Id w equals w a2:Type
     { yyValue = new KeywordType(createSpan(yyStart,yyCount), a1, a2); };

/* SimpleTupleType ::= ( w Type w , w TypeList w ) */
TupleType SimpleTupleType =
     openparen w a1:Type w comma w a2:TypeList w closeparen
     { List<Type> ts = FortressUtil.mkList(a1, a2);
       yyValue = NodeFactory.makeTupleType(createSpan(yyStart,yyCount), ts,
                                           None.<VarargsType>make());
     };

/* TypeList ::= Type (w , w Type)* */
List<Type> TypeList = a1:Type a2s:(w comma w Type)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* DimType ::=
     DimRef
   | Type sr DimRef
   | Type w . w DimRef
   | Type w / w DimRef
   | Type w per w DimRef
   | Type sr UnitRef
   | Type w . w UnitRef
   | Type w / w UnitRef
   | Type w per w UnitRef
   | Type w in w DimRef
 */
/* ************************************************
 * Not Yet Implemented ***************************
private DimType DimType =
     seed:DimTypeFront list:TypeTail*
     { yyValue = (DimType)apply(list, seed); };

private Type DimTypeFront =
     a1:DimRef
************************************************ */

/* DimRef ::= StaticArg */
DimRef DimRef = a1:StaticArg
     { yyValue = new DimRef(createSpan(yyStart,yyCount), a1); };

/* DimExpr ::=
     Unity
   | DottedId
   | DimExpr sr DimExpr
   | DimExpr w DOT w DimExpr
   | DimExpr w / w DimExpr
   | DimExpr w per w DimExpr
   | 1 w / w DimExpr
   | DimExpr ^ Number
   | ( w DimExpr w )
   | DUPreOp sr DimExpr
   | DimExpr w DUPostOp
 */
DimExpr DimExpr =
     seed:DimExprFront list:DimExprTail*
     { yyValue = (DimExpr)apply(list, seed); };

private DimExpr DimExprFront =
     "Unity"
     { yyValue = new BaseDim(createSpan(yyStart,yyCount)); }
   / a1:DottedId
     { yyValue = new DimId(createSpan(yyStart,yyCount), a1); }
   / one w slash w a2:DimExpr
     { yyValue = new QuotientDim(createSpan(yyStart,yyCount),
                                 new BaseDim(createSpan(yyStart,1)), a2); }
   / openparen w a1:DimExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); }
   / a1:DUPreOp sr a2:DimExpr
     { yyValue = new OpDim(createSpan(yyStart,yyCount), a2, a1); };

private constant transient Action<DimExpr> DimExprTail =
     ProductDim
   / QuotientDim
   / ExponentDim
   / OpDim
   ;

private constant inline Action<DimExpr> ProductDim =
     (w DOT w / sr) a1:DimExpr
     { yyValue = new Action<DimExpr>() {
           public DimExpr run(DimExpr base) {
               return new ProductDim(createSpan(yyStart,yyCount), (DimExpr)base,
                                     a1);
           }};
     };

private constant inline Action<DimExpr> QuotientDim =
     w (slash / per) w a1:DimExpr
     { yyValue = new Action<DimExpr>() {
           public DimExpr run(DimExpr base) {
               return new QuotientDim(createSpan(yyStart,yyCount), (DimExpr)base,
                                      a1);
           }};
     };

private constant inline Action<DimExpr> ExponentDim =
     caret a1:Number
     { yyValue = new Action<DimExpr>() {
           public DimExpr run(DimExpr base) {
               return new ExponentDim(createSpan(yyStart,yyCount), (DimExpr)base,
                                      a1);
           }};
     };

private constant inline Action<DimExpr> OpDim =
     w a1:DUPostOp
     { yyValue = new Action<DimExpr>() {
           public DimExpr run(DimExpr base) {
               return new OpDim(createSpan(yyStart,yyCount), (DimExpr)base, a1);
           }};
     };

/* StaticArgList ::= StaticArg (w , w StaticArg)*  */
List<StaticArg> StaticArgList = a1:StaticArg a2s:(w comma w StaticArg)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* StaticArg ::=
     Number
   | Op
   | true
   | false
   | Unity
   | dimensionless
   | StaticArg w + w StaticArg
   | StaticArg w - w StaticArg
   | StaticArg w / w StaticArg
   | 1 w / w StaticArg
   | StaticArg ^ IntVal
   | StaticArg w per w StaticArg
   | DUPreOp sr StaticArg
   | StaticArg w DUPostOp
   | NOT w StaticArg
   | StaticArg w OR w StaticArg
   | StaticArg w AND w StaticArg
   | StaticArg w IMPLIES w StaticArg
   | StaticArg w = w StaticArg
   | StaticArg w DOT w StaticArg
   | StaticArg sr StaticArg
   | Type
   | ( StaticArg )
 */
private StaticArg StaticArg =
     seed:StaticArgFront list:StaticArgTail*
     { yyValue = (StaticArg)apply(list, seed); };

private StaticArg StaticArgFront =
     a1:Number
     { yyValue = NodeFactory.makeBaseNatStaticArg(createSpan(yyStart,yyCount), a1); }
   / a1:Op
     { yyValue = NodeFactory.makeBaseOprStaticArg(createSpan(yyStart,yyCount), a1); }
   / "true"
     { yyValue = new BaseBoolStaticArg(createSpan(yyStart,yyCount), true); }
   / "false"
     { yyValue = new BaseBoolStaticArg(createSpan(yyStart,yyCount), false); }
   / "Unity"
     { yyValue = new BaseDimStaticArg(createSpan(yyStart,yyCount)); }
   / "dimensionless"
     { yyValue = new BaseUnitStaticArg(createSpan(yyStart,yyCount)); }
   / one w slash w a1:StaticArg
     { Span span = createSpan(yyStart,1);
       StaticArg one = NodeFactory.makeBaseNatStaticArg(span, ExprFactory.makeIntLiteral(span, "1"));
       yyValue = new QuotientStaticArg(createSpan(yyStart,yyCount), one, a1);
     }
   / a1:DUPreOp sr a2:StaticArg
     { yyValue = new DimensionStaticArg(createSpan(yyStart,yyCount), a2, a1); }
   / "NOT":op w a1:StaticArg
     { yyValue = new NotStaticArg(createSpan(yyStart,yyCount), a1); }
   / a1:Type
     { yyValue = new TypeArg(createSpan(yyStart,yyCount), a1); }
   / openparen a1:StaticArg closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); };

private constant transient Action<StaticArg> StaticArgTail =
     SumStaticArg
   / MinusStaticArg
   / QuotientStaticArg
   / ExponentStaticArg
   / DimensionStaticArg
   / EqualsStaticArg
   / OrStaticArg
   / AndStaticArg
   / ImpliesStaticArg
   / ProductStaticArg
   ;

private constant inline Action<StaticArg> SumStaticArg =
     w plus w a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new SumStaticArg(createSpan(yyStart,yyCount),
                                       (StaticArg)base, a1);
           }};
     };

private constant inline Action<StaticArg> MinusStaticArg =
     w minus w a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new MinusStaticArg(createSpan(yyStart,yyCount),
                                         (StaticArg)base, a1);
           }};
     };

private constant inline Action<StaticArg> QuotientStaticArg =
     w (slash / per) w a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new QuotientStaticArg(createSpan(yyStart,yyCount),
                                            (StaticArg)base, a1);
           }};
     };

private constant inline Action<StaticArg> ExponentStaticArg =
     caret a1:IntVal
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new ExponentStaticArg(createSpan(yyStart,yyCount),
                                            (StaticArg)base, a1);
           }};
     };

private constant inline Action<StaticArg> DimensionStaticArg =
     w a1:DUPostOp
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new DimensionStaticArg(createSpan(yyStart,yyCount),
                                             (StaticArg)base, a1);
           }};
     };

private constant inline Action<StaticArg> EqualsStaticArg =
     w equals w a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new EqualsStaticArg(createSpan(yyStart,yyCount),
                                          (StaticArg)base, a1);
           }};
     };

private constant inline Action<StaticArg> OrStaticArg =
     w "OR":op w a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new OrStaticArg(createSpan(yyStart,yyCount),
                                      (StaticArg)base, a1);
           }};
     };

private constant inline Action<StaticArg> AndStaticArg =
     w "AND":op w a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new AndStaticArg(createSpan(yyStart,yyCount),
                                           (StaticArg)base, a1);
           }};
     };

private constant inline Action<StaticArg> ImpliesStaticArg =
     w "IMPLIES":op w a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new ImpliesStaticArg(createSpan(yyStart,yyCount),
                                               (StaticArg)base, a1);
           }};
     };

private constant inline Action<StaticArg> ProductStaticArg =
     (w DOT w / sr) a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new ProductStaticArg(createSpan(yyStart,yyCount),
                                           (StaticArg)base, a1);
           }};
     };

/* DUPreOp ::= square | cubic | inverse */
DimUnitOp DUPreOp =
     square  { yyValue = new SquareDimUnit(createSpan(yyStart,yyCount));  }
   / cubic   { yyValue = new CubicDimUnit(createSpan(yyStart,yyCount));   }
   / inverse { yyValue = new InverseDimUnit(createSpan(yyStart,yyCount)); };

/* DUPostOp ::= squared | cubed */
DimUnitOp DUPostOp =
     squared { yyValue = new SquareDimUnit(createSpan(yyStart,yyCount)); }
   / cubed   { yyValue = new CubicDimUnit(createSpan(yyStart,yyCount));  };

/* ArraySize ::= ExtentRange (w , w ExtentRange)* */
private FixedDim ArraySize = a1:ExtentRange a2s:(w comma w ExtentRange)*
     { List<ExtentRange> es = FortressUtil.mkList(a1, a2s.list());
       yyValue = new FixedDim(createSpan(yyStart,yyCount), es);
     };

/* ExtentRange ::=
     (StaticArg w)? # (w StaticArg)?
   | (StaticArg w)? : (w StaticArg)?
   | StaticArg
 */
ExtentRange ExtentRange =
     a1:(StaticArg w)? pound a2:(w StaticArg)?
     { Option<StaticArg> base;
       Option<StaticArg> size;
       if (a1 == null) base = None.<StaticArg>make();
       else            base = Some.<StaticArg>make(a1);
       if (a2 == null) size = None.<StaticArg>make();
       else            size = Some.<StaticArg>make(a2);
       yyValue = new ExtentRange(createSpan(yyStart,yyCount), base, size);
     }
   / a1:(StaticArg w)? colon a2:(w StaticArg)?
     { Option<StaticArg> base;
       Option<StaticArg> size;
       if (a1 == null) base = None.<StaticArg>make();
       else            base = Some.<StaticArg>make(a1);
       if (a2 == null) size = None.<StaticArg>make();
       else            size = Some.<StaticArg>make(a2);
       yyValue = new ExtentRange(createSpan(yyStart,yyCount), base, size);
     }
   / a1:StaticArg
     { yyValue = new ExtentRange(createSpan(yyStart,yyCount),
                                 None.<StaticArg>make(),
                                 Some.<StaticArg>make(a1));
     };

/* Number */
IntLiteral Number = IntLiteral ;
