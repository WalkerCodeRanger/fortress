/*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress types.
 */
module Type(Header, Literal, Identifier, Keyword, Symbol, Spacing);

import Header;
import Literal;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* IsType ::= : w TypeRef */
TypeRef IsType = colon w TypeRef ;

/* NonArrowType, TraitType, and DimType are mutually left recursive.
   We've inlined them into each other and removed the left recursion. */
/* TypeRef ::=
     ( w TypeRef w )
   | ArrowType
   | NonArrowType

   ArrowType ::= NonArrowType w -> w NonArrowType (w Throws)?

   NonArrowType ::=
     TraitType
   | TupleType
   | ( w )
   | DimType

   TraitType ::=
     DottedId (w [\ w StaticArgList w \])?
   | TypeRef w [ (w ArraySize)? w ]
   | TypeRef ^ StaticArgFront
   | TypeRef ^ ( w ExtentRange (w x w ExtentRange)* w )

   DimType ::=
     DimRef
   | TypeRef sr DimRef
   | TypeRef w . w DimRef
   | TypeRef w / w DimRef
   | TypeRef w per w DimRef
   | TypeRef sr UnitRef
   | TypeRef w . w UnitRef
   | TypeRef w / w UnitRef
   | TypeRef w per w UnitRef
   | TypeRef w in w DimRef
 */
constant transient TypeRef TypeRef =
     seed:TypeRefFront list:TypeRefTail*
     { yyValue = (TypeRef)apply(list, seed); };

private TypeRef TypeRefFront =
     openparen w a1:TypeRef w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); }
   / a1:TypeRefFrontNonArrow w rightarrow w a2:NonArrowType a3:(w Throws)?
     { Option<List<TraitType>> throws_;
       if (a3 == null) throws_ = None.<List<TraitType>>make();
       else            throws_ = Some.<List<TraitType>>make(a3);
       yyValue = NodeFactory.makeArrowType(createSpan(yyStart,yyCount), a1, a2,
                                           throws_);
     }
   / TypeRefFrontNonArrow ;

private NonArrowType TypeRefFrontNonArrow =
     a1:DottedId a2:(w opendoublesquare w StaticArgList w closedoublesquare)?
     { if (a2 == null) yyValue = new IdType(createSpan(yyStart,yyCount), a1);
       else yyValue = new InstantiatedType(createSpan(yyStart,yyCount), a1, a2);
     }
   / TupleType
   / openparen w closeparen
     { yyValue = new VoidType(createSpan(yyStart,yyCount)); };

private constant transient Action<TypeRef> TypeRefTail =
     w opensquare a1:(w ArraySize)? w closesquare a2:ArrowTypeTail?
     { yyValue = new Action<TypeRef>() {
           public TypeRef run(TypeRef base) {
               Option<FixedDim> indices;
               if (a1 == null) indices = None.<FixedDim>make();
               else            indices = Some.<FixedDim>make(a1);
               NonArrowType ty =
                   NodeFactory.makeArrayType(createSpan(yyStart,yyCount),
                                             (TypeRef)base, indices);
               if (a2 == null) return ty;
               else return NodeFactory.makeArrowType(createSpan(yyStart,yyCount),
                                                     ty, a2.getRange(),
                                                     a2.getThrows());
           }};
     }
   / caret a1:StaticArgFront a2:ArrowTypeTail?
     { yyValue = new Action<TypeRef>() {
           public TypeRef run(TypeRef base) {
               ExtentRange er = new ExtentRange(None.<StaticArg>make(),
                                                Some.<StaticArg>make(a1));
               NonArrowType ty =
                   NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),
                                              (TypeRef)base, er);
               if (a2 == null) return ty;
               else return NodeFactory.makeArrowType(createSpan(yyStart,yyCount),
                                                     ty, a2.getRange(),
                                                     a2.getThrows());
           }};
     }
   / caret openparen w a1:ExtentRange a2s:(w cross w ExtentRange)* w closeparen
     a3:ArrowTypeTail?
     { yyValue = new Action<TypeRef>() {
           public TypeRef run(TypeRef base) {
               NonArrowType ty =
                   NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),
                                              (TypeRef)base,a1,a2s.list());

               if (a3 == null) return ty;
               else return NodeFactory.makeArrowType(createSpan(yyStart,yyCount),
                                                     ty, a3.getRange(),
                                                     a3.getThrows());
           }};
     };

private ArrowTypeTail ArrowTypeTail =
     w rightarrow w a1:NonArrowType a2:(w Throws)?
     { Option<List<TraitType>> throws_;
       if (a2 == null) throws_ = None.<List<TraitType>>make();
       else            throws_ = Some.<List<TraitType>>make(a2);
       yyValue = new ArrowTypeTail(a1, throws_);
     };

/* ArrowType ::= NonArrowType w -> w NonArrowType (w Throws)? */
ArrowType ArrowType =
     a1:NonArrowType w rightarrow w a2:NonArrowType a3:(w Throws)?
     { Option<List<TraitType>> throws_;
       if (a3 == null) throws_ = None.<List<TraitType>>make();
       else            throws_ = Some.<List<TraitType>>make(a3);
       yyValue = NodeFactory.makeArrowType(createSpan(yyStart,yyCount),
                                           a1, a2, throws_);
     };

private NonArrowType NonArrowType =
     TraitType
   / TupleType
   / openparen w closeparen
     { yyValue = new VoidType(createSpan(yyStart,yyCount)); }
/* ************************************************
 * Not Yet Implemented ***************************
   / DimType
************************************************ */
   ;

/* TraitType ::=
     DottedId (w [\ w StaticArgList w \])?
   | TypeRef [ (w ArraySize)? w ]
   | TypeRef ^ StaticArgFront
   | TypeRef ^ ( w ExtentRange (w x w ExtentRange)* w )
 */
TraitType TraitType =
     a1:DottedId a2:(w opendoublesquare w StaticArgList w closedoublesquare)?
     { if (a2 == null) yyValue = new IdType(createSpan(yyStart,yyCount), a1);
       else yyValue = new InstantiatedType(createSpan(yyStart,yyCount), a1, a2);
     }
   / a1:TypeRef w opensquare a2:(w ArraySize)? w closesquare
     { Option<FixedDim> indices;
       if (a2 == null) indices = None.<FixedDim>make();
       else            indices = Some.<FixedDim>make(a2);
       yyValue = NodeFactory.makeArrayType(createSpan(yyStart,yyCount), a1,
                                           indices);
     }
   / a1:TypeRef caret a2:StaticArgFront
     { ExtentRange er = new ExtentRange(None.<StaticArg>make(),
                                        Some.<StaticArg>make(a2));
       yyValue = NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),a1,er);
     }
   / a1:TypeRef caret openparen w a2:ExtentRange a3s:(w cross w ExtentRange)* w
     closeparen
     { yyValue = NodeFactory.makeMatrixType(createSpan(yyStart,yyCount), a1, a2,
                                            a3s.list());
     };

/* ************************************************
 * Not Yet Implemented ***************************
private constant inline Action<TypeRef> ProductDimType =
     sr a1:DimRef
     { yyValue = new Action<TypeRef>() {
           public TypeRef run(TypeRef base) {
               return new ProductDimType(createSpan(yyStart,yyCount),
                                         (TypeRef)base, a1);
           }};
     }
   / w "DOT":op w a1:DimRef
     { yyValue = new Action<TypeRef>() {
           public TypeRef run(TypeRef base) {
               return new ProductDimType(createSpan(yyStart,yyCount),
                                         (TypeRef)base, a1);
           }};
     };

private constant inline Action<TypeRef> QuotientDimType =
     w "slash":op w a1:DimRef
     { yyValue = new Action<TypeRef>() {
           public TypeRef run(TypeRef base) {
               return new QuotientDimType(createSpan(yyStart,yyCount),
                                          (TypeRef)base, a1);
           }};
     }
   / w "per":op w a1:DimRef
     { yyValue = new Action<TypeRef>() {
           public TypeRef run(TypeRef base) {
               return new QuotientDimType(createSpan(yyStart,yyCount),
                                          (TypeRef)base, a1);
           }};
     };

private constant inline Action<TypeRef> ProductUnitType =
     sr a1:UnitRef
     { yyValue = new Action<TypeRef>() {
           public TypeRef run(TypeRef base) {
               return new ProductUnitType(createSpan(yyStart,yyCount),
                                          (TypeRef)base, a1);
           }};
     }
   / w "DOT":op w a1:UnitRef
     { yyValue = new Action<TypeRef>() {
           public TypeRef run(TypeRef base) {
               return new ProductUnitType(createSpan(yyStart,yyCount),
                                          (TypeRef)base, a1);
           }};
     };

private constant inline Action<TypeRef> QuotientUnitType =
     w "slash":op w a1:UnitRef
     { yyValue = new Action<TypeRef>() {
           public TypeRef run(TypeRef base) {
               return new QuotientUnitType(createSpan(yyStart,yyCount),
                                           (TypeRef)base, a1);
           }};
     }
   / w "per":op w a1:UnitRef
     { yyValue = new Action<TypeRef>() {
           public TypeRef run(TypeRef base) {
               return new QuotientUnitType(createSpan(yyStart,yyCount),
                                           (TypeRef)base, a1);
           }};
     };
************************************************ */

private constant inline Action<TypeRef> DimTypeConversion =
     w "in":op w a1:DimRef
     { yyValue = new Action<TypeRef>() {
           public TypeRef run(TypeRef base) {
               return new DimTypeConversion(createSpan(yyStart,yyCount),
                                            (TypeRef)base, a1);
           }};
     };

/* TupleType ::=
     ( w (TypeRef w , w)* (TypeRef w ... w , w)? KeywordType (w , w KeywordType)* w )
   | ( w (TypeRef w , w)* TypeRef w ... w )
   | SimpleTupleType
 */
TypeRef TupleType =
     openparen w a1s:(TypeRef w comma w)* a2:(TypeRef w ellipses w comma w)?
       a3:KeywordType a4s:(w comma w KeywordType)* w closeparen
     { List<TypeRef>   ts1 = a1s.list();
       Option<VarargsType> ts2 = ((a2 != null)?
                                   Some.<VarargsType>make(new VarargsType(createSpan(yyStart,yyCount), a2)) :
                                   None.<VarargsType>make());
       List<KeywordType> ts3 = a4s.list();
       ts3.add(0, a3);
       yyValue = new TupleType(createSpan(yyStart,yyCount), ts1, ts2, ts3);
     }
   / openparen w a1s:(TypeRef w comma w)* a2:TypeRef w ellipses w closeparen
     { List<TypeRef> ts1 = FortressUtil.mkList(a1s.list());
       Option<VarargsType> ts2 = Some.<VarargsType>make(new VarargsType(createSpan(yyStart,yyCount), a2));
       yyValue = NodeFactory.makeTupleType(createSpan(yyStart,yyCount), ts1, ts2);
     }
   / SimpleTupleType ;

/* KeywordType ::= Id w = w TypeRef */
private KeywordType KeywordType = a1:Id w equals w a2:TypeRef
     { yyValue = new KeywordType(createSpan(yyStart,yyCount), a1, a2); };

/* SimpleTupleType ::= ( w TypeRef w , w TypeRefList w ) */
TupleType SimpleTupleType =
     openparen w a1:TypeRef w comma w a2:TypeRefList w closeparen
     { List<TypeRef> ts = FortressUtil.mkList(a1, a2);
       yyValue = NodeFactory.makeTupleType(createSpan(yyStart,yyCount), ts,
                                           None.<VarargsType>make());
     };

/* TypeRefList ::= TypeRef (w , w TypeRef)* */
List<TypeRef> TypeRefList = a1:TypeRef a2s:(w comma w TypeRef)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* DimType ::=
     DimRef
   | TypeRef sr DimRef
   | TypeRef w . w DimRef
   | TypeRef w / w DimRef
   | TypeRef w per w DimRef
   | TypeRef sr UnitRef
   | TypeRef w . w UnitRef
   | TypeRef w / w UnitRef
   | TypeRef w per w UnitRef
   | TypeRef w in w DimRef
 */
/* ************************************************
 * Not Yet Implemented ***************************
private DimType DimType =
     seed:DimTypeFront list:TypeRefTail*
     { yyValue = (DimType)apply(list, seed); };

private TypeRef DimTypeFront =
     a1:DimRef
************************************************ */

/* DimRef ::= StaticArg */
DimRef DimRef = a1:StaticArg
     { yyValue = new DimRef(createSpan(yyStart,yyCount), a1); };

/* DimExpr ::=
     Unity
   | DottedId
   | DimExpr sr DimExpr
   | DimExpr w DOT w DimExpr
   | DimExpr w / w DimExpr
   | DimExpr w per w DimExpr
   | 1 w / w DimExpr
   | DimExpr ^ Number
   | ( w DimExpr w )
   | DUPreOp sr DimExpr
   | DimExpr w DUPostOp
 */
DimExpr DimExpr =
     seed:DimExprFront list:DimExprTail*
     { yyValue = (DimExpr)apply(list, seed); };

private DimExpr DimExprFront =
     "Unity"
     { yyValue = new BaseDim(createSpan(yyStart,yyCount)); }
   / a1:DottedId
     { yyValue = new DimId(createSpan(yyStart,yyCount), a1); }
   / one w slash w a2:DimExpr
     { yyValue = new QuotientDim(createSpan(yyStart,yyCount),
                                 new BaseDim(createSpan(yyStart,1)), a2); }
   / openparen w a1:DimExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); }
   / a1:DUPreOp sr a2:DimExpr
     { yyValue = new OpDim(createSpan(yyStart,yyCount), a2, a1); };

private constant transient Action<DimExpr> DimExprTail =
     ProductDim
   / QuotientDim
   / ExponentDim
   / OpDim
   ;

private constant inline Action<DimExpr> ProductDim =
     (w DOT w / sr) a1:DimExpr
     { yyValue = new Action<DimExpr>() {
           public DimExpr run(DimExpr base) {
               return new ProductDim(createSpan(yyStart,yyCount), (DimExpr)base,
                                     a1);
           }};
     };

private constant inline Action<DimExpr> QuotientDim =
     w (slash / per) w a1:DimExpr
     { yyValue = new Action<DimExpr>() {
           public DimExpr run(DimExpr base) {
               return new QuotientDim(createSpan(yyStart,yyCount), (DimExpr)base,
                                      a1);
           }};
     };

private constant inline Action<DimExpr> ExponentDim =
     caret a1:Number
     { yyValue = new Action<DimExpr>() {
           public DimExpr run(DimExpr base) {
               return new ExponentDim(createSpan(yyStart,yyCount), (DimExpr)base,
                                      a1);
           }};
     };

private constant inline Action<DimExpr> OpDim =
     w a1:DUPostOp
     { yyValue = new Action<DimExpr>() {
           public DimExpr run(DimExpr base) {
               return new OpDim(createSpan(yyStart,yyCount), (DimExpr)base, a1);
           }};
     };

/* StaticArgList ::= StaticArg (w , w StaticArg)*  */
List<StaticArg> StaticArgList = a1:StaticArg a2s:(w comma w StaticArg)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* StaticArg ::=
     Number
   | Op
   | true
   | false
   | Unity
   | dimensionless
   | StaticArg w + w StaticArg
   | StaticArg w - w StaticArg
   | StaticArg sr StaticArg
   | StaticArg w DOT w StaticArg
   | StaticArg w / w StaticArg
   | 1 w / w StaticArg
   | StaticArg ^ IntVal
   | StaticArg w per w StaticArg
   | DUPreOp sr StaticArg
   | StaticArg w DUPostOp
   | NOT w StaticArg
   | StaticArg w OR w StaticArg
   | StaticArg w AND w StaticArg
   | StaticArg w IMPLIES w StaticArg
   | StaticArg w = w StaticArg
   | TypeRef
   | ( StaticArg )
 */
private StaticArg StaticArg =
     seed:StaticArgFront list:StaticArgTail*
     { yyValue = (StaticArg)apply(list, seed); };

private StaticArg StaticArgFront =
     a1:Number
     { yyValue = NodeFactory.makeBaseNatRef(createSpan(yyStart,yyCount), a1); }
   / a1:Op
     { yyValue = NodeFactory.makeBaseOprRef(createSpan(yyStart,yyCount), a1); }
   / "true"
     { yyValue = new BaseBoolRef(createSpan(yyStart,yyCount), true); }
   / "false"
     { yyValue = new BaseBoolRef(createSpan(yyStart,yyCount), false); }
   / "Unity"
     { yyValue = new BaseDimRef(createSpan(yyStart,yyCount)); }
   / "dimensionless"
     { yyValue = new BaseUnitRef(createSpan(yyStart,yyCount)); }
   / one w slash w a1:StaticArg
     { Span span = createSpan(yyStart,1);
       StaticArg one = NodeFactory.makeBaseNatRef(span, ExprFactory.makeIntLiteral(span, "1"));
       yyValue = new QuotientStaticArg(createSpan(yyStart,yyCount), one, a1);
     }
   / a1:DUPreOp sr a2:StaticArg
     { yyValue = new DimensionStaticArg(createSpan(yyStart,yyCount), a2, a1); }
   / "NOT":op w a1:StaticArg
     { yyValue = new NotBoolRef(createSpan(yyStart,yyCount), a1); }
   / a1:TypeRef
     { yyValue = new TypeArg(createSpan(yyStart,yyCount), a1); }
   / openparen StaticArg closeparen;

private constant transient Action<StaticArg> StaticArgTail =
     SumStaticArg
   / ProductStaticArg
   / QuotientStaticArg
   / ExponentStaticArg
   / DimensionStaticArg
   / OrStaticArg
   / AndStaticArg
   / ImpliesStaticArg
   ;

private constant inline Action<StaticArg> SumStaticArg =
     w plus w a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               List<StaticArg> vs = FortressUtil.mkList((StaticArg)base, a1);
               return new SumStaticArg(createSpan(yyStart,yyCount), vs);
           }};
     };

private constant inline Action<StaticArg> ProductStaticArg =
     (w DOT w / sr) a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               List<StaticArg> vs = FortressUtil.mkList((StaticArg)base, a1);
               return new ProductStaticArg(createSpan(yyStart,yyCount), vs);
           }};
     };

private constant inline Action<StaticArg> QuotientStaticArg =
     w (slash / per) w a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new QuotientStaticArg(createSpan(yyStart,yyCount),
                                            (TypeRef)base, a1);
           }};
     };

private constant inline Action<StaticArg> ExponentStaticArg =
     caret a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new ExponentStaticArg(createSpan(yyStart,yyCount),
                                            (TypeRef)base, a1);
           }};
     };

private constant inline Action<StaticArg> DimensionStaticArg =
     w a1:DUPostOp
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new DimensionStaticArg(createSpan(yyStart,yyCount),
                                             (StaticArg)base, a1);
           }};
     };

private constant inline Action<StaticArg> OrStaticArg =
     w "OR":op w a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new OrBoolRef(createSpan(yyStart,yyCount),
                                    (StaticArg)base, a1);
           }};
     };

private constant inline Action<StaticArg> AndStaticArg =
     w "AND":op w a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new AndBoolRef(createSpan(yyStart,yyCount),
                                     (StaticArg)base, a1);
           }};
     };

private constant inline Action<StaticArg> ImpliesStaticArg =
     w "IMPLIES":op w a1:StaticArg
     { yyValue = new Action<StaticArg>() {
           public StaticArg run(StaticArg base) {
               return new ImpliesBoolRef(createSpan(yyStart,yyCount),
                                         (StaticArg)base, a1);
           }};
     };

/* DUPreOp ::= square | cubic | inverse */
DimUnitOp DUPreOp =
     square  { yyValue = new SquareDimUnit(createSpan(yyStart,yyCount));  }
   / cubic   { yyValue = new CubicDimUnit(createSpan(yyStart,yyCount));   }
   / inverse { yyValue = new InverseDimUnit(createSpan(yyStart,yyCount)); };

/* DUPostOp ::= squared | cubed */
DimUnitOp DUPostOp =
     squared { yyValue = new SquareDimUnit(createSpan(yyStart,yyCount)); }
   / cubed   { yyValue = new CubicDimUnit(createSpan(yyStart,yyCount));  };

/* ArraySize ::= ExtentRange (w , w ExtentRange)* */
private FixedDim ArraySize = a1:ExtentRange a2s:(w comma w ExtentRange)*
     { List<ExtentRange> es = FortressUtil.mkList(a1, a2s.list());
       yyValue = new FixedDim(createSpan(yyStart,yyCount), es);
     };

/* ExtentRange ::=
     (StaticArg w)? # (w StaticArg)?
   | (StaticArg w)? : (w StaticArg)?
   | StaticArg
 */
ExtentRange ExtentRange =
     a1:(StaticArg w)? pound a2:(w StaticArg)?
     { Option<StaticArg> base;
       Option<StaticArg> size;
       if (a1 == null) base = None.<StaticArg>make();
       else            base = Some.<StaticArg>make(a1);
       if (a2 == null) size = None.<StaticArg>make();
       else            size = Some.<StaticArg>make(a2);
       yyValue = new ExtentRange(createSpan(yyStart,yyCount), base, size);
     }
   / a1:(StaticArg w)? colon a2:(w StaticArg)?
     { Option<StaticArg> base;
       Option<StaticArg> size;
       if (a1 == null) base = None.<StaticArg>make();
       else            base = Some.<StaticArg>make(a1);
       if (a2 == null) size = None.<StaticArg>make();
       else            size = Some.<StaticArg>make(a2);
       yyValue = new ExtentRange(createSpan(yyStart,yyCount), base, size);
     }
   / a1:StaticArg
     { yyValue = new ExtentRange(createSpan(yyStart,yyCount),
                                 None.<StaticArg>make(),
                                 Some.<StaticArg>make(a1));
     };

/* Number */
IntLiteral Number = IntLiteral ;
